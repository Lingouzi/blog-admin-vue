/* WebUploader 0.1.2 */!(function(a, b) { let c; const d = {}; const e = function(a, b) { let c, d, e; if (typeof a === 'string') return h(a); for (c = [], d = a.length, e = 0; d > e; e++)c.push(h(a[e])); return b.apply(null, c) }; const f = function(a, b, c) { arguments.length === 2 && (c = b, b = null), e(b || [], function() { g(a, c, arguments) }) }; var g = function(a, b, c) { let f; const g = { exports: b }; typeof b === 'function' && (c.length || (c = [e, g.exports, g]), f = b.apply(null, c), void 0 !== f && (g.exports = f)), d[a] = g.exports }; var h = function(b) { const c = d[b] || a[b]; if (!c) throw new Error('`' + b + '` is undefined'); return c }; const i = function(a) { let b, c, e, f, g, h; h = function(a) { return a && a.charAt(0).toUpperCase() + a.substr(1) }; for (b in d) if (c = a, d.hasOwnProperty(b)) { for (e = b.split('/'), g = h(e.pop()); f = h(e.shift());)c[f] = c[f] || {}, c = c[f]; c[g] = d[b] } }; const j = b(a, f, e); i(j), typeof module === 'object' && typeof module.exports === 'object' ? module.exports = j : typeof define === 'function' && define.amd ? define([], j) : (c = a.WebUploader, a.WebUploader = j, a.WebUploader.noConflict = function() { a.WebUploader = c }) }(this, function(a, b, c) {
    return b('dollar-third', [], function() { return a.jQuery || a.Zepto }), b('dollar', ['dollar-third'], function(a) { return a }), b('promise-third', ['dollar'], function(a) { return { Deferred: a.Deferred, when: a.when, isPromise: function(a) { return a && typeof a.then === 'function' } } }), b('promise', ['promise-third'], function(a) { return a }), b('base', ['dollar', 'promise'], function(b, c) { function d(a) { return function() { return h.apply(a, arguments) } } function e(a, b) { return function() { return a.apply(b, arguments) } } function f(a) { let b; return Object.create ? Object.create(a) : (b = function() {}, b.prototype = a, new b()) } const g = function() {}; var h = Function.call; return { version: '0.1.2', $: b, Deferred: c.Deferred, isPromise: c.isPromise, when: c.when, browser: (function(a) { const b = {}; const c = a.match(/WebKit\/([\d.]+)/); const d = a.match(/Chrome\/([\d.]+)/) || a.match(/CriOS\/([\d.]+)/); const e = a.match(/MSIE\s([\d\.]+)/) || a.match(/(?:trident)(?:.*rv:([\w.]+))?/i); const f = a.match(/Firefox\/([\d.]+)/); const g = a.match(/Safari\/([\d.]+)/); const h = a.match(/OPR\/([\d.]+)/); return c && (b.webkit = parseFloat(c[1])), d && (b.chrome = parseFloat(d[1])), e && (b.ie = parseFloat(e[1])), f && (b.firefox = parseFloat(f[1])), g && (b.safari = parseFloat(g[1])), h && (b.opera = parseFloat(h[1])), b }(navigator.userAgent)), os: (function(a) { const b = {}; const c = a.match(/(?:Android);?[\s\/]+([\d.]+)?/); const d = a.match(/(?:iPad|iPod|iPhone).*OS\s([\d_]+)/); return c && (b.android = parseFloat(c[1])), d && (b.ios = parseFloat(d[1].replace(/_/g, '.'))), b }(navigator.userAgent)), inherits: function(a, c, d) { let e; return typeof c === 'function' ? (e = c, c = null) : e = c && c.hasOwnProperty('constructor') ? c.constructor : function() { return a.apply(this, arguments) }, b.extend(!0, e, a, d || {}), e.__super__ = a.prototype, e.prototype = f(a.prototype), c && b.extend(!0, e.prototype, c), e }, noop: g, bindFn: e, log: (function() { return a.console ? e(console.log, console) : g }()), nextTick: (function() { return function(a) { setTimeout(a, 1) } }()), slice: d([].slice), guid: (function() { let a = 0; return function(b) { for (var c = (+new Date()).toString(32), d = 0; d < 5; d++)c += Math.floor(65535 * Math.random()).toString(32); return (b || 'wu_') + c + (a++).toString(32) } }()), formatSize: function(a, b, c) { let d; for (c = c || ['B', 'K', 'M', 'G', 'TB']; (d = c.shift()) && a > 1024;)a /= 1024; return (d === 'B' ? a : a.toFixed(b || 2)) + d } } }), b('mediator', ['base'], function(a) { function b(a, b, c, d) { return f.grep(a, function(a) { return !(!a || b && a.e !== b || c && a.cb !== c && a.cb._cb !== c || d && a.ctx !== d) }) } function c(a, b, c) { f.each((a || '').split(h), function(a, d) { c(d, b) }) } function d(a, b) { for (var c, d = !1, e = -1, f = a.length; ++e < f;) if (c = a[e], c.cb.apply(c.ctx2, b) === !1) { d = !0; break } return !d } let e; var f = a.$; const g = [].slice; var h = /\s+/; return e = { on: function(a, b, d) { let e; const f = this; return b ? (e = this._events || (this._events = []), c(a, b, function(a, b) { const c = { e: a }; c.cb = b, c.ctx = d, c.ctx2 = d || f, c.id = e.length, e.push(c) }), this) : this }, once: function(a, b, d) { const e = this; return b ? (c(a, b, function(a, b) { var c = function() { return e.off(a, c), b.apply(d || e, arguments) }; c._cb = b, e.on(a, c, d) }), e) : e }, off: function(a, d, e) { const g = this._events; return g ? a || d || e ? (c(a, d, function(a, c) { f.each(b(g, a, c, e), function() { delete g[this.id] }) }), this) : (this._events = [], this) : this }, trigger: function(a) { let c, e, f; return this._events && a ? (c = g.call(arguments, 1), e = b(this._events, a), f = b(this._events, 'all'), d(e, c) && d(f, arguments)) : this } }, f.extend({ installTo: function(a) { return f.extend(a, e) } }, e) }), b('uploader', ['base', 'mediator'], function(a, b) { function c(a) { this.options = d.extend(!0, {}, c.options, a), this._init(this.options) } var d = a.$; return c.options = {}, b.installTo(c.prototype), d.each({ upload: 'start-upload', stop: 'stop-upload', getFile: 'get-file', getFiles: 'get-files', addFile: 'add-file', addFiles: 'add-file', sort: 'sort-files', removeFile: 'remove-file', skipFile: 'skip-file', retry: 'retry', isInProgress: 'is-in-progress', makeThumb: 'make-thumb', getDimension: 'get-dimension', addButton: 'add-btn', getRuntimeType: 'get-runtime-type', refresh: 'refresh', disable: 'disable', enable: 'enable', reset: 'reset' }, function(a, b) { c.prototype[a] = function() { return this.request(b, arguments) } }), d.extend(c.prototype, { state: 'pending', _init: function(a) { const b = this; b.request('init', a, function() { b.state = 'ready', b.trigger('ready') }) }, option: function(a, b) { const c = this.options; return arguments.length > 1 ? void (d.isPlainObject(b) && d.isPlainObject(c[a]) ? d.extend(c[a], b) : c[a] = b) : a ? c[a] : c }, getStats: function() { const a = this.request('get-stats'); return { successNum: a.numOfSuccess, cancelNum: a.numOfCancel, invalidNum: a.numOfInvalid, uploadFailNum: a.numOfUploadFailed, queueNum: a.numOfQueue } }, trigger: function(a) { const c = [].slice.call(arguments, 1); const e = this.options; const f = 'on' + a.substring(0, 1).toUpperCase() + a.substring(1); return b.trigger.apply(this, arguments) === !1 || d.isFunction(e[f]) && e[f].apply(this, c) === !1 || d.isFunction(this[f]) && this[f].apply(this, c) === !1 || b.trigger.apply(b, [this, a].concat(c)) === !1 ? !1 : !0 }, request: a.noop }), a.create = c.create = function(a) { return new c(a) }, a.Uploader = c, c }), b('runtime/runtime', ['base', 'mediator'], function(a, b) { function c(b) { this.options = d.extend({ container: document.body }, b), this.uid = a.guid('rt_') } var d = a.$; const e = {}; const f = function(a) { for (const b in a) if (a.hasOwnProperty(b)) return b; return null }; return d.extend(c.prototype, { getContainer: function() { let a; let b; const c = this.options; return this._container ? this._container : (a = d(c.container || document.body), b = d(document.createElement('div')), b.attr('id', 'rt_' + this.uid), b.css({ position: 'absolute', top: '0px', left: '0px', width: '1px', height: '1px', overflow: 'hidden' }), a.append(b), a.addClass('webuploader-container'), this._container = b, b) }, init: a.noop, exec: a.noop, destroy: function() { this._container && this._container.parentNode.removeChild(this.__container), this.off() } }), c.orders = 'html5,flash', c.addRuntime = function(a, b) { e[a] = b }, c.hasRuntime = function(a) { return !!(a ? e[a] : f(e)) }, c.create = function(a, b) { let g, h; if (b = b || c.orders, d.each(b.split(/\s*,\s*/g), function() { return e[this] ? (g = this, !1) : void 0 }), g = g || f(e), !g) throw new Error('Runtime Error'); return h = new e[g](a) }, b.installTo(c.prototype), c }), b('runtime/client', ['base', 'mediator', 'runtime/runtime'], function(a, b, c) { function d(b, d) { let f; const g = a.Deferred(); this.uid = a.guid('client_'), this.runtimeReady = function(a) { return g.done(a) }, this.connectRuntime = function(b, h) { if (f) throw new Error('already connected!'); return g.done(h), typeof b === 'string' && e.get(b) && (f = e.get(b)), f = f || e.get(null, d), f ? (a.$.extend(f.options, b), f.__promise.then(g.resolve), f.__client++) : (f = c.create(b, b.runtimeOrder), f.__promise = g.promise(), f.once('ready', g.resolve), f.init(), e.add(f), f.__client = 1), d && (f.__standalone = d), f }, this.getRuntime = function() { return f }, this.disconnectRuntime = function() { f && (f.__client--, f.__client <= 0 && (e.remove(f), delete f.__promise, f.destroy()), f = null) }, this.exec = function() { if (f) { const c = a.slice(arguments); return b && c.unshift(b), f.exec.apply(this, c) } }, this.getRuid = function() { return f && f.uid }, this.destroy = (function(a) { return function() { a && a.apply(this, arguments), this.trigger('destroy'), this.off(), this.exec('destroy'), this.disconnectRuntime() } }(this.destroy)) } let e; return e = (function() { const a = {}; return { add: function(b) { a[b.uid] = b }, get: function(b, c) { let d; if (b) return a[b]; for (d in a) if (!c || !a[d].__standalone) return a[d]; return null }, remove: function(b) { delete a[b.uid] } } }()), b.installTo(d.prototype), d }), b('lib/dnd', ['base', 'mediator', 'runtime/client'], function(a, b, c) { function d(a) { a = this.options = e.extend({}, d.options, a), a.container = e(a.container), a.container.length && c.call(this, 'DragAndDrop') } var e = a.$; return d.options = { accept: null, disableGlobalDnd: !1 }, a.inherits(c, { constructor: d, init: function() { const a = this; a.connectRuntime(a.options, function() { a.exec('init'), a.trigger('ready') }) }, destroy: function() { this.disconnectRuntime() } }), b.installTo(d.prototype), d }), b('widgets/widget', ['base', 'uploader'], function(a, b) { function c(a) { if (!a) return !1; const b = a.length; const c = e.type(a); return a.nodeType === 1 && b ? !0 : c === 'array' || c !== 'function' && c !== 'string' && (b === 0 || typeof b === 'number' && b > 0 && b - 1 in a) } function d(a) { this.owner = a, this.options = a.options } var e = a.$; const f = b.prototype._init; const g = {}; const h = []; return e.extend(d.prototype, { init: a.noop, invoke: function(a, b) { const c = this.responseMap; return c && a in c && c[a] in this && e.isFunction(this[c[a]]) ? this[c[a]].apply(this, b) : g }, request: function() { return this.owner.request.apply(this.owner, arguments) } }), e.extend(b.prototype, { _init: function() { const a = this; const b = a._widgets = []; return e.each(h, function(c, d) { b.push(new d(a)) }), f.apply(a, arguments) }, request: function(b, d, e) { let f; let h; let i; let j; let k = 0; const l = this._widgets; const m = l.length; const n = []; const o = []; for (d = c(d) ? d : [d]; m > k; k++)f = l[k], h = f.invoke(b, d), h !== g && (a.isPromise(h) ? o.push(h) : n.push(h)); return e || o.length ? (i = a.when.apply(a, o), j = i.pipe ? 'pipe' : 'then', i[j](function() { const b = a.Deferred(); const c = arguments; return setTimeout(function() { b.resolve.apply(b, c) }, 1), b.promise() })[j](e || a.noop)) : n[0] } }), b.register = d.register = function(b, c) { let f; const g = { init: 'init' }; return arguments.length === 1 ? (c = b, c.responseMap = g) : c.responseMap = e.extend(g, b), f = a.inherits(d, c), h.push(f), f }, d }), b('widgets/filednd', ['base', 'uploader', 'lib/dnd', 'widgets/widget'], function(a, b, c) { const d = a.$; return b.options.dnd = '', b.register({ init: function(b) { if (b.dnd && this.request('predict-runtime-type') === 'html5') { let e; const f = this; const g = a.Deferred(); const h = d.extend({}, { disableGlobalDnd: b.disableGlobalDnd, container: b.dnd, accept: b.accept }); return e = new c(h), e.once('ready', g.resolve), e.on('drop', function(a) { f.request('add-file', [a]) }), e.on('accept', function(a) { return f.owner.trigger('dndAccept', a) }), e.init(), g.promise() } } }) }), b('lib/filepaste', ['base', 'mediator', 'runtime/client'], function(a, b, c) { function d(a) { a = this.options = e.extend({}, a), a.container = e(a.container || document.body), c.call(this, 'FilePaste') } var e = a.$; return a.inherits(c, { constructor: d, init: function() { const a = this; a.connectRuntime(a.options, function() { a.exec('init'), a.trigger('ready') }) }, destroy: function() { this.exec('destroy'), this.disconnectRuntime(), this.off() } }), b.installTo(d.prototype), d }), b('widgets/filepaste', ['base', 'uploader', 'lib/filepaste', 'widgets/widget'], function(a, b, c) { const d = a.$; return b.register({ init: function(b) { if (b.paste && this.request('predict-runtime-type') === 'html5') { let e; const f = this; const g = a.Deferred(); const h = d.extend({}, { container: b.paste, accept: b.accept }); return e = new c(h), e.once('ready', g.resolve), e.on('paste', function(a) { f.owner.request('add-file', [a]) }), e.init(), g.promise() } } }) }), b('lib/blob', ['base', 'runtime/client'], function(a, b) { function c(a, c) { const d = this; d.source = c, d.ruid = a, b.call(d, 'Blob'), this.uid = c.uid || this.uid, this.type = c.type || '', this.size = c.size || 0, a && d.connectRuntime(a) } return a.inherits(b, { constructor: c, slice: function(a, b) { return this.exec('slice', a, b) }, getSource: function() { return this.source } }), c }), b('lib/file', ['base', 'lib/blob'], function(a, b) { function c(a, c) { let f; b.apply(this, arguments), this.name = c.name || 'untitled' + d++, f = e.exec(c.name) ? RegExp.$1.toLowerCase() : '', !f && this.type && (f = /\/(jpg|jpeg|png|gif|bmp)$/i.exec(this.type) ? RegExp.$1.toLowerCase() : '', this.name += '.' + f), !this.type && ~'jpg,jpeg,png,gif,bmp'.indexOf(f) && (this.type = 'image/' + (f === 'jpg' ? 'jpeg' : f)), this.ext = f, this.lastModifiedDate = c.lastModifiedDate || (new Date()).toLocaleString() } var d = 1; var e = /\.([^.]+)$/; return a.inherits(b, c) }), b('lib/filepicker', ['base', 'runtime/client', 'lib/file'], function(b, c, d) {
        function e(a) { if (a = this.options = f.extend({}, e.options, a), a.container = f(a.id), !a.container.length) throw new Error('按钮指定错误'); a.innerHTML = a.innerHTML || a.label || a.container.html() || '', a.button = f(a.button || document.createElement('div')), a.button.html(a.innerHTML), a.container.html(a.button), c.call(this, 'FilePicker', !0) } var f = b.$; return e.options = { button: null, container: null, label: null, innerHTML: null, multiple: !0, accept: null, name: 'file' }, b.inherits(c, { constructor: e, init: function() { const b = this; const c = b.options; const e = c.button; e.addClass('webuploader-pick'), b.on('all', function(a) { let g; switch (a) { case 'mouseenter':e.addClass('webuploader-pick-hover'); break; case 'mouseleave':e.removeClass('webuploader-pick-hover'); break; case 'change':g = b.exec('getFiles'), b.trigger('select', f.map(g, function(a) { return a = new d(b.getRuid(), a), a._refer = c.container, a }), c.container) } }), b.connectRuntime(c, function() { b.refresh(), b.exec('init', c), b.trigger('ready') }), f(a).on('resize', function() { b.refresh() }) }, refresh: function() { const a = this.getRuntime().getContainer(); const b = this.options.button; const c = b.outerWidth ? b.outerWidth() : b.width(); const d = b.outerHeight ? b.outerHeight() : b.height(); const e = b.offset(); c && d && a.css({ bottom: 'auto', right: 'auto', width: c + 'px', height: d + 'px' }).offset(e) }, enable: function() { const a = this.options.button; a.removeClass('webuploader-pick-disable'), this.refresh() }, disable: function() {
            const a = this.options.button; this.getRuntime().getContainer()
                .css({ top: '-99999px' }), a.addClass('webuploader-pick-disable')
        }, destroy: function() { this.runtime && (this.exec('destroy'), this.disconnectRuntime()) } }), e
    }), b('widgets/filepicker', ['base', 'uploader', 'lib/filepicker', 'widgets/widget'], function(a, b, c) { const d = a.$; return d.extend(b.options, { pick: null, accept: null }), b.register({ 'add-btn': 'addButton', refresh: 'refresh', disable: 'disable', enable: 'enable' }, { init: function(a) { return this.pickers = [], a.pick && this.addButton(a.pick) }, refresh: function() { d.each(this.pickers, function() { this.refresh() }) }, addButton: function(b) { let e; let f; let g; const h = this; const i = h.options; const j = i.accept; if (b) return g = a.Deferred(), d.isPlainObject(b) || (b = { id: b }), e = d.extend({}, b, { accept: d.isPlainObject(j) ? [j] : j, swf: i.swf, runtimeOrder: i.runtimeOrder }), f = new c(e), f.once('ready', g.resolve), f.on('select', function(a) { h.owner.request('add-file', [a]) }), f.init(), this.pickers.push(f), g.promise() }, disable: function() { d.each(this.pickers, function() { this.disable() }) }, enable: function() { d.each(this.pickers, function() { this.enable() }) } }) }), b('lib/image', ['base', 'runtime/client', 'lib/blob'], function(a, b, c) { function d(a) { this.options = e.extend({}, d.options, a), b.call(this, 'Image'), this.on('load', function() { this._info = this.exec('info'), this._meta = this.exec('meta') }) } var e = a.$; return d.options = { quality: 90, crop: !1, preserveHeaders: !0, allowMagnify: !0 }, a.inherits(b, { constructor: d, info: function(a) { return a ? (this._info = a, this) : this._info }, meta: function(a) { return a ? (this._meta = a, this) : this._meta }, loadFromBlob: function(a) { const b = this; const c = a.getRuid(); this.connectRuntime(c, function() { b.exec('init', b.options), b.exec('loadFromBlob', a) }) }, resize: function() { const b = a.slice(arguments); return this.exec.apply(this, ['resize'].concat(b)) }, getAsDataUrl: function(a) { return this.exec('getAsDataUrl', a) }, getAsBlob: function(a) { const b = this.exec('getAsBlob', a); return new c(this.getRuid(), b) } }), d }), b('widgets/image', ['base', 'uploader', 'lib/image', 'widgets/widget'], function(a, b, c) { let d; const e = a.$; return d = (function(a) { let b = 0; const c = []; const d = function() { for (var d; c.length && a > b;)d = c.shift(), b += d[0], d[1]() }; return function(a, e, f) { c.push([e, f]), a.once('destroy', function() { b -= e, setTimeout(d, 1) }), setTimeout(d, 1) } }(5242880)), e.extend(b.options, { thumb: { width: 110, height: 110, quality: 70, allowMagnify: !0, crop: !0, preserveHeaders: !1, type: 'image/jpeg' }, compress: { width: 1600, height: 1600, quality: 90, allowMagnify: !1, crop: !1, preserveHeaders: !0 } }), b.register({ 'make-thumb': 'makeThumb', 'before-send-file': 'compressImage' }, { makeThumb: function(a, b, f, g) { let h, i; return a = this.request('get-file', a), a.type.match(/^image/) ? (h = e.extend({}, this.options.thumb), e.isPlainObject(f) && (h = e.extend(h, f), f = null), f = f || h.width, g = g || h.height, i = new c(h), i.once('load', function() { a._info = a._info || i.info(), a._meta = a._meta || i.meta(), i.resize(f, g) }), i.once('complete', function() { b(!1, i.getAsDataUrl(h.type)), i.destroy() }), i.once('error', function() { b(!0), i.destroy() }), void d(i, a.source.size, function() { a._info && i.info(a._info), a._meta && i.meta(a._meta), i.loadFromBlob(a.source) })) : void b(!0) }, compressImage: function(b) { let d; let f; let g = this.options.compress || this.options.resize; const h = g && g.compressSize || 307200; return b = this.request('get-file', b), !g || !~'image/jpeg,image/jpg'.indexOf(b.type) || b.size < h || b._compressed ? void 0 : (g = e.extend({}, g), f = a.Deferred(), d = new c(g), f.always(function() { d.destroy(), d = null }), d.once('error', f.reject), d.once('load', function() { b._info = b._info || d.info(), b._meta = b._meta || d.meta(), d.resize(g.width, g.height) }), d.once('complete', function() { let a, c; try { a = d.getAsBlob(g.type), c = b.size, a.size < c && (b.source = a, b.size = a.size, b.trigger('resize', a.size, c)), b._compressed = !0, f.resolve() } catch (e) { f.resolve() } }), b._info && d.info(b._info), b._meta && d.meta(b._meta), d.loadFromBlob(b.source), f.promise()) } }) }), b('file', ['base', 'mediator'], function(a, b) { function c() { return f + g++ } function d(a) { this.name = a.name || 'Untitled', this.size = a.size || 0, this.type = a.type || 'application', this.lastModifiedDate = a.lastModifiedDate || 1 * new Date(), this.id = c(), this.ext = h.exec(this.name) ? RegExp.$1 : '', this.statusText = '', i[this.id] = d.Status.INITED, this.source = a, this.loaded = 0, this.on('error', function(a) { this.setStatus(d.Status.ERROR, a) }) } const e = a.$; var f = 'WU_FILE_'; var g = 0; var h = /\.([^.]+)$/; var i = {}; return e.extend(d.prototype, { setStatus: function(a, b) { const c = i[this.id]; typeof b !== 'undefined' && (this.statusText = b), a !== c && (i[this.id] = a, this.trigger('statuschange', a, c)) }, getStatus: function() { return i[this.id] }, getSource: function() { return this.source }, destory: function() { delete i[this.id] } }), b.installTo(d.prototype), d.Status = { INITED: 'inited', QUEUED: 'queued', PROGRESS: 'progress', ERROR: 'error', COMPLETE: 'complete', CANCELLED: 'cancelled', INTERRUPT: 'interrupt', INVALID: 'invalid' }, d }), b('queue', ['base', 'mediator', 'file'], function(a, b, c) { function d() { this.stats = { numOfQueue: 0, numOfSuccess: 0, numOfCancel: 0, numOfProgress: 0, numOfUploadFailed: 0, numOfInvalid: 0 }, this._queue = [], this._map = {} } const e = a.$; const f = c.Status; return e.extend(d.prototype, { append: function(a) { return this._queue.push(a), this._fileAdded(a), this }, prepend: function(a) { return this._queue.unshift(a), this._fileAdded(a), this }, getFile: function(a) { return typeof a !== 'string' ? a : this._map[a] }, fetch: function(a) { let b; let c; const d = this._queue.length; for (a = a || f.QUEUED, b = 0; d > b; b++) if (c = this._queue[b], a === c.getStatus()) return c; return null }, sort: function(a) { typeof a === 'function' && this._queue.sort(a) }, getFiles: function() { for (var a, b = [].slice.call(arguments, 0), c = [], d = 0, f = this._queue.length; f > d; d++)a = this._queue[d], (!b.length || ~e.inArray(a.getStatus(), b)) && c.push(a); return c }, _fileAdded: function(a) { const b = this; const c = this._map[a.id]; c || (this._map[a.id] = a, a.on('statuschange', function(a, c) { b._onFileStatusChange(a, c) })), a.setStatus(f.QUEUED) }, _onFileStatusChange: function(a, b) { const c = this.stats; switch (b) { case f.PROGRESS:c.numOfProgress--; break; case f.QUEUED:c.numOfQueue--; break; case f.ERROR:c.numOfUploadFailed--; break; case f.INVALID:c.numOfInvalid-- } switch (a) { case f.QUEUED:c.numOfQueue++; break; case f.PROGRESS:c.numOfProgress++; break; case f.ERROR:c.numOfUploadFailed++; break; case f.COMPLETE:c.numOfSuccess++; break; case f.CANCELLED:c.numOfCancel++; break; case f.INVALID:c.numOfInvalid++ } } }), b.installTo(d.prototype), d }), b('widgets/queue', ['base', 'uploader', 'queue', 'file', 'lib/file', 'runtime/client', 'widgets/widget'], function(a, b, c, d, e, f) {
        const g = a.$; const h = /\.\w+$/; const i = d.Status; return b.register({ 'sort-files': 'sortFiles', 'add-file': 'addFiles', 'get-file': 'getFile', 'fetch-file': 'fetchFile', 'get-stats': 'getStats', 'get-files': 'getFiles', 'remove-file': 'removeFile', retry: 'retry', reset: 'reset', 'accept-file': 'acceptFile' }, { init: function(b) {
            let d; let e; let h; let i; let j; let k; let l; const m = this; if (g.isPlainObject(b.accept) && (b.accept = [b.accept]), b.accept) {
                for (j = [], h = 0, e = b.accept.length; e > h; h++)i = b.accept[h].extensions, i && j.push(i); j.length && (k = '\\.' + j.join(',').replace(/,/g, '$|\\.')
                    .replace(/\*/g, '.*') + '$'), m.accept = new RegExp(k, 'i')
            } return m.queue = new c(), m.stats = m.queue.stats, this.request('predict-runtime-type') === 'html5' ? (d = a.Deferred(), l = new f('Placeholder'), l.connectRuntime({ runtimeOrder: 'html5' }, function() { m._ruid = l.getRuid(), d.resolve() }), d.promise()) : void 0
        }, _wrapFile: function(a) { if (!(a instanceof d)) { if (!(a instanceof e)) { if (!this._ruid) throw new Error("Can't add external files."); a = new e(this._ruid, a) }a = new d(a) } return a }, acceptFile: function(a) { const b = !a || a.size < 6 || this.accept && h.exec(a.name) && !this.accept.test(a.name); return !b }, _addFile: function(a) { const b = this; return a = b._wrapFile(a), b.owner.trigger('beforeFileQueued', a) ? b.acceptFile(a) ? (b.queue.append(a), b.owner.trigger('fileQueued', a), a) : void b.owner.trigger('error', 'Q_TYPE_DENIED', a) : void 0 }, getFile: function(a) { return this.queue.getFile(a) }, addFiles: function(a) { const b = this; a.length || (a = [a]), a = g.map(a, function(a) { return b._addFile(a) }), b.owner.trigger('filesQueued', a), b.options.auto && b.request('start-upload') }, getStats: function() { return this.stats }, removeFile: function(a) { const b = this; a = a.id ? a : b.queue.getFile(a), a.setStatus(i.CANCELLED), b.owner.trigger('fileDequeued', a) }, getFiles: function() { return this.queue.getFiles.apply(this.queue, arguments) }, fetchFile: function() { return this.queue.fetch.apply(this.queue, arguments) }, retry: function(a, b) { let c; let d; let e; const f = this; if (a) return a = a.id ? a : f.queue.getFile(a), a.setStatus(i.QUEUED), void (b || f.request('start-upload')); for (c = f.queue.getFiles(i.ERROR), d = 0, e = c.length; e > d; d++)a = c[d], a.setStatus(i.QUEUED); f.request('start-upload') }, sortFiles: function() { return this.queue.sort.apply(this.queue, arguments) }, reset: function() { this.queue = new c(), this.stats = this.queue.stats } })
    }), b('widgets/runtime', ['uploader', 'runtime/runtime', 'widgets/widget'], function(a, b) { return a.support = function() { return b.hasRuntime.apply(b, arguments) }, a.register({ 'predict-runtime-type': 'predictRuntmeType' }, { init: function() { if (!this.predictRuntmeType()) throw Error('Runtime Error') }, predictRuntmeType: function() { let a; let c; let d = this.options.runtimeOrder || b.orders; let e = this.type; if (!e) for (d = d.split(/\s*,\s*/g), a = 0, c = d.length; c > a; a++) if (b.hasRuntime(d[a])) { this.type = e = d[a]; break } return e } }) }), b('lib/transport', ['base', 'runtime/client', 'mediator'], function(a, b, c) { function d(a) { const c = this; a = c.options = e.extend(!0, {}, d.options, a || {}), b.call(this, 'Transport'), this._blob = null, this._formData = a.formData || {}, this._headers = a.headers || {}, this.on('progress', this._timeout), this.on('load error', function() { c.trigger('progress', 1), clearTimeout(c._timer) }) } var e = a.$; return d.options = { server: '', method: 'POST', withCredentials: !1, fileVal: 'file', timeout: 12e4, formData: {}, headers: {}, sendAsBinary: !1 }, e.extend(d.prototype, { appendBlob: function(a, b, c) { const d = this; const e = d.options; d.getRuid() && d.disconnectRuntime(), d.connectRuntime(b.ruid, function() { d.exec('init') }), d._blob = b, e.fileVal = a || e.fileVal, e.filename = c || e.filename }, append: function(a, b) { typeof a === 'object' ? e.extend(this._formData, a) : this._formData[a] = b }, setRequestHeader: function(a, b) { typeof a === 'object' ? e.extend(this._headers, a) : this._headers[a] = b }, send: function(a) { this.exec('send', a), this._timeout() }, abort: function() { return clearTimeout(this._timer), this.exec('abort') }, destroy: function() { this.trigger('destroy'), this.off(), this.exec('destroy'), this.disconnectRuntime() }, getResponse: function() { return this.exec('getResponse') }, getResponseAsJson: function() { return this.exec('getResponseAsJson') }, getStatus: function() { return this.exec('getStatus') }, _timeout: function() { const a = this; const b = a.options.timeout; b && (clearTimeout(a._timer), a._timer = setTimeout(function() { a.abort(), a.trigger('error', 'timeout') }, b)) } }), c.installTo(d.prototype), d }), b('widgets/upload', ['base', 'uploader', 'file', 'lib/transport', 'widgets/widget'], function(a, b, c, d) {
        function e(a, b) { for (var c, d = [], e = a.source, f = e.size, g = b ? Math.ceil(f / b) : 1, h = 0, i = 0; g > i;)c = Math.min(b, f - h), d.push({ file: a, start: h, end: b ? h + c : f, total: f, chunks: g, chunk: i++ }), h += c; return a.blocks = d.concat(), a.remaning = d.length, { file: a, has: function() { return !!d.length }, fetch: function() { return d.shift() } } } const f = a.$; const g = a.isPromise; const h = c.Status; f.extend(b.options, { prepareNextFile: !1, chunked: !1, chunkSize: 5242880, chunkRetry: 2, threads: 3, formData: null }), b.register({ 'start-upload': 'start', 'stop-upload': 'stop', 'skip-file': 'skipFile', 'is-in-progress': 'isInProgress' }, { init: function() { const b = this.owner; this.runing = !1, this.pool = [], this.pending = [], this.remaning = 0, this.__tick = a.bindFn(this._tick, this), b.on('uploadComplete', function(a) { a.blocks && f.each(a.blocks, function(a, b) { b.transport && (b.transport.abort(), b.transport.destroy()), delete b.transport }), delete a.blocks, delete a.remaning }) }, start: function() { const b = this; f.each(b.request('get-files', h.INVALID), function() { b.request('remove-file', this) }), b.runing || (b.runing = !0, f.each(b.pool, function(a, c) { const d = c.file; d.getStatus() === h.INTERRUPT && (d.setStatus(h.PROGRESS), b._trigged = !1, c.transport && c.transport.send()) }), b._trigged = !1, b.owner.trigger('startUpload'), a.nextTick(b.__tick)) }, stop: function(a) { const b = this; b.runing !== !1 && (b.runing = !1, a && f.each(b.pool, function(a, b) { b.transport && b.transport.abort(), b.file.setStatus(h.INTERRUPT) }), b.owner.trigger('stopUpload')) }, isInProgress: function() { return !!this.runing }, getStats: function() { return this.request('get-stats') }, skipFile: function(a, b) { a = this.request('get-file', a), a.setStatus(b || h.COMPLETE), a.skipped = !0, a.blocks && f.each(a.blocks, function(a, b) { const c = b.transport; c && (c.abort(), c.destroy(), delete b.transport) }), this.owner.trigger('uploadSkip', a) }, _tick: function() { let b; let c; const d = this; const e = d.options; return d._promise ? d._promise.always(d.__tick) : void (d.pool.length < e.threads && (c = d._nextBlock()) ? (d._trigged = !1, b = function(b) { d._promise = null, b && b.file && d._startSend(b), a.nextTick(d.__tick) }, d._promise = g(c) ? c.always(b) : b(c)) : d.remaning || d.getStats().numOfQueue || (d.runing = !1, d._trigged || a.nextTick(function() { d.owner.trigger('uploadFinished') }), d._trigged = !0)) }, _nextBlock: function() { let a; let b; const c = this; let d = c._act; const f = c.options; return d && d.has() && d.file.getStatus() === h.PROGRESS ? (f.prepareNextFile && !c.pending.length && c._prepareNextFile(), d.fetch()) : c.runing ? (!c.pending.length && c.getStats().numOfQueue && c._prepareNextFile(), a = c.pending.shift(), b = function(a) { return a ? (d = e(a, f.chunked ? f.chunkSize : 0), c._act = d, d.fetch()) : null }, g(a) ? a[a.pipe ? 'pipe' : 'then'](b) : b(a)) : void 0 }, _prepareNextFile: function() { let a; const b = this; const c = b.request('fetch-file'); const d = b.pending; c && (a = b.request('before-send-file', c, function() { return c.getStatus() === h.QUEUED ? (b.owner.trigger('uploadStart', c), c.setStatus(h.PROGRESS), c) : b._finishFile(c) }), a.done(function() { const b = f.inArray(a, d); ~b && d.splice(b, 1, c) }), a.fail(function(a) { c.setStatus(h.ERROR, a), b.owner.trigger('uploadError', c, a), b.owner.trigger('uploadComplete', c) }), d.push(a)) }, _popBlock: function(a) { const b = f.inArray(a, this.pool); this.pool.splice(b, 1), a.file.remaning--, this.remaning-- }, _startSend: function(b) { let c; const d = this; const e = b.file; d.pool.push(b), d.remaning++, b.blob = b.chunks === 1 ? e.source : e.source.slice(b.start, b.end), c = d.request('before-send', b, function() { e.getStatus() === h.PROGRESS ? d._doSend(b) : (d._popBlock(b), a.nextTick(d.__tick)) }), c.fail(function() { e.remaning === 1 ? d._finishFile(e).always(function() { b.percentage = 1, d._popBlock(b), d.owner.trigger('uploadComplete', e), a.nextTick(d.__tick) }) : (b.percentage = 1, d._popBlock(b), a.nextTick(d.__tick)) }) }, _doSend: function(b) { let c; let e; const g = this; const i = g.owner; const j = g.options; const k = b.file; const l = new d(j); let m = f.extend({}, j.formData); const n = f.extend({}, j.headers); b.transport = l, l.on('destroy', function() { delete b.transport, g._popBlock(b), a.nextTick(g.__tick) }), l.on('progress', function(a) { let c = 0; let d = 0; c = b.percentage = a, b.chunks > 1 && (f.each(k.blocks, function(a, b) { d += (b.percentage || 0) * (b.end - b.start) }), c = d / k.size), i.trigger('uploadProgress', k, c || 0) }), c = function(a) { let c; return e = l.getResponseAsJson() || {}, e._raw = l.getResponse(), c = function(b) { a = b }, i.trigger('uploadAccept', b, e, c) || (a = a || 'server'), a }, l.on('error', function(a, d) { b.retried = b.retried || 0, b.chunks > 1 && ~'http,abort'.indexOf(a) && b.retried < j.chunkRetry ? (b.retried++, l.send()) : (d || a !== 'server' || (a = c(a)), k.setStatus(h.ERROR, a), i.trigger('uploadError', k, a), i.trigger('uploadComplete', k)) }), l.on('load', function() { let a; return (a = c()) ? void l.trigger('error', a, !0) : void (k.remaning === 1 ? g._finishFile(k, e) : l.destroy()) }), m = f.extend(m, { id: k.id, name: k.name, type: k.type, lastModifiedDate: k.lastModifiedDate, size: k.size }), b.chunks > 1 && f.extend(m, { chunks: b.chunks, chunk: b.chunk }), i.trigger('uploadBeforeSend', b, m, n), l.appendBlob(j.fileVal, b.blob, k.name), l.append(m), l.setRequestHeader(n), l.send() }, _finishFile: function(a, b, c) {
            const d = this.owner; return d.request('after-send-file', arguments, function() { a.setStatus(h.COMPLETE), d.trigger('uploadSuccess', a, b, c) }).fail(function(b) { a.getStatus() === h.PROGRESS && a.setStatus(h.ERROR, b), d.trigger('uploadError', a, b) })
                .always(function() { d.trigger('uploadComplete', a) })
        } })
    }), b('widgets/validator', ['base', 'uploader', 'file', 'widgets/widget'], function(a, b, c) { let d; const e = a.$; const f = {}; return d = { addValidator: function(a, b) { f[a] = b }, removeValidator: function(a) { delete f[a] } }, b.register({ init: function() { const a = this; e.each(f, function() { this.call(a.owner) }) } }), d.addValidator('fileNumLimit', function() { const a = this; const b = a.options; let c = 0; const d = b.fileNumLimit >> 0; let e = !0; d && (a.on('beforeFileQueued', function(a) { return c >= d && e && (e = !1, this.trigger('error', 'Q_EXCEED_NUM_LIMIT', d, a), setTimeout(function() { e = !0 }, 1)), c >= d ? !1 : !0 }), a.on('fileQueued', function() { c++ }), a.on('fileDequeued', function() { c-- }), a.on('uploadFinished', function() { c = 0 })) }), d.addValidator('fileSizeLimit', function() { const a = this; const b = a.options; let c = 0; const d = b.fileSizeLimit >> 0; let e = !0; d && (a.on('beforeFileQueued', function(a) { const b = c + a.size > d; return b && e && (e = !1, this.trigger('error', 'Q_EXCEED_SIZE_LIMIT', d, a), setTimeout(function() { e = !0 }, 1)), b ? !1 : !0 }), a.on('fileQueued', function(a) { c += a.size }), a.on('fileDequeued', function(a) { c -= a.size }), a.on('uploadFinished', function() { c = 0 })) }), d.addValidator('fileSingleSizeLimit', function() { const a = this; const b = a.options; const d = b.fileSingleSizeLimit; d && a.on('beforeFileQueued', function(a) { return a.size > d ? (a.setStatus(c.Status.INVALID, 'exceed_size'), this.trigger('error', 'F_EXCEED_SIZE', a), !1) : void 0 }) }), d.addValidator('duplicate', function() { function a(a) { for (var b, c = 0, d = 0, e = a.length; e > d; d++)b = a.charCodeAt(d), c = b + (c << 6) + (c << 16) - c; return c } const b = this; const c = b.options; const d = {}; c.duplicate || (b.on('beforeFileQueued', function(b) { const c = b.__hash || (b.__hash = a(b.name + b.size + b.lastModifiedDate)); return d[c] ? (this.trigger('error', 'F_DUPLICATE', b), !1) : void 0 }), b.on('fileQueued', function(a) { const b = a.__hash; b && (d[b] = !0) }), b.on('fileDequeued', function(a) { const b = a.__hash; b && delete d[b] })) }), d }), b('runtime/compbase', [], function() { function a(a, b) { this.owner = a, this.options = a.options, this.getRuntime = function() { return b }, this.getRuid = function() { return b.uid }, this.trigger = function() { return a.trigger.apply(a, arguments) } } return a }), b('runtime/html5/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function(b, c, d) { function e() { const a = {}; const d = this; const e = this.destory; c.apply(d, arguments), d.type = f, d.exec = function(c, e) { let f; const h = this; const i = h.uid; const j = b.slice(arguments, 2); return g[c] && (f = a[i] = a[i] || new g[c](h, d), f[e]) ? f[e].apply(f, j) : void 0 }, d.destory = function() { return e && e.apply(this, arguments) } } var f = 'html5'; var g = {}; return b.inherits(c, { constructor: e, init: function() { const a = this; setTimeout(function() { a.trigger('ready') }, 1) } }), e.register = function(a, c) { const e = g[a] = b.inherits(d, c); return e }, a.Blob && a.FileReader && a.DataView && c.addRuntime(f, e), e }), b('runtime/html5/blob', ['runtime/html5/runtime', 'lib/blob'], function(a, b) { return a.register('Blob', { slice: function(a, c) { let d = this.owner.source; const e = d.slice || d.webkitSlice || d.mozSlice; return d = e.call(d, a, c), new b(this.getRuid(), d) } }) }), b('runtime/html5/dnd', ['base', 'runtime/html5/runtime', 'lib/file'], function(a, b, c) {
        const d = a.$; const e = 'webuploader-dnd-'; return b.register('DragAndDrop', { init: function() {
            const b = this.elem = this.options.container; this.dragEnterHandler = a.bindFn(this._dragEnterHandler, this), this.dragOverHandler = a.bindFn(this._dragOverHandler, this), this.dragLeaveHandler = a.bindFn(this._dragLeaveHandler, this), this.dropHandler = a.bindFn(this._dropHandler, this), this.dndOver = !1, b.on('dragenter', this.dragEnterHandler), b.on('dragover', this.dragOverHandler), b.on('dragleave', this.dragLeaveHandler), b.on('drop', this.dropHandler), this.options.disableGlobalDnd && (d(document).on('dragover', this.dragOverHandler), d(document).on('drop', this.dropHandler))
        }, _dragEnterHandler: function(a) { let b; const c = this; let d = c._denied || !1; return a = a.originalEvent || a, c.dndOver || (c.dndOver = !0, b = a.dataTransfer.items, b && b.length && (c._denied = d = !c.trigger('accept', b)), c.elem.addClass(e + 'over'), c.elem[d ? 'addClass' : 'removeClass'](e + 'denied')), a.dataTransfer.dropEffect = d ? 'none' : 'copy', !1 }, _dragOverHandler: function(a) { const b = this.elem.parent().get(0); return b && !d.contains(b, a.currentTarget) ? !1 : (clearTimeout(this._leaveTimer), this._dragEnterHandler.call(this, a), !1) }, _dragLeaveHandler: function() { let a; const b = this; return a = function() { b.dndOver = !1, b.elem.removeClass(e + 'over ' + e + 'denied') }, clearTimeout(b._leaveTimer), b._leaveTimer = setTimeout(a, 100), !1 }, _dropHandler: function(a) { const b = this; const f = b.getRuid(); const g = b.elem.parent().get(0); return g && !d.contains(g, a.currentTarget) ? !1 : (b._getTansferFiles(a, function(a) { b.trigger('drop', d.map(a, function(a) { return new c(f, a) })) }), b.dndOver = !1, b.elem.removeClass(e + 'over'), !1) }, _getTansferFiles: function(b, c) { let d; let e; let f; let g; let h; let i; let j; let k; const l = []; const m = []; for (b = b.originalEvent || b, f = b.dataTransfer, d = f.items, e = f.files, k = !(!d || !d[0].webkitGetAsEntry), i = 0, j = e.length; j > i; i++)g = e[i], h = d && d[i], k && h.webkitGetAsEntry().isDirectory ? m.push(this._traverseDirectoryTree(h.webkitGetAsEntry(), l)) : l.push(g); a.when.apply(a, m).done(function() { l.length && c(l) }) }, _traverseDirectoryTree: function(b, c) { const d = a.Deferred(); const e = this; return b.isFile ? b.file(function(a) { c.push(a), d.resolve() }) : b.isDirectory && b.createReader().readEntries(function(b) { let f; const g = b.length; const h = []; const i = []; for (f = 0; g > f; f++)h.push(e._traverseDirectoryTree(b[f], i)); a.when.apply(a, h).then(function() { c.push.apply(c, i), d.resolve() }, d.reject) }), d.promise() }, destroy: function() { const a = this.elem; a.off('dragenter', this.dragEnterHandler), a.off('dragover', this.dragEnterHandler), a.off('dragleave', this.dragLeaveHandler), a.off('drop', this.dropHandler), this.options.disableGlobalDnd && (d(document).off('dragover', this.dragOverHandler), d(document).off('drop', this.dropHandler)) } })
    }), b('runtime/html5/filepaste', ['base', 'runtime/html5/runtime', 'lib/file'], function(a, b, c) { return b.register('FilePaste', { init: function() { let b; let c; let d; let e; const f = this.options; const g = this.elem = f.container; let h = '.*'; if (f.accept) { for (b = [], c = 0, d = f.accept.length; d > c; c++)e = f.accept[c].mimeTypes, e && b.push(e); b.length && (h = b.join(','), h = h.replace(/,/g, '|').replace(/\*/g, '.*')) } this.accept = h = new RegExp(h, 'i'), this.hander = a.bindFn(this._pasteHander, this), g.on('paste', this.hander) }, _pasteHander: function(a) { let b; let d; let e; let f; let g; const h = []; const i = this.getRuid(); for (a = a.originalEvent || a, b = a.clipboardData.items, f = 0, g = b.length; g > f; f++)d = b[f], d.kind === 'file' && (e = d.getAsFile()) && h.push(new c(i, e)); h.length && (a.preventDefault(), a.stopPropagation(), this.trigger('paste', h)) }, destroy: function() { this.elem.off('paste', this.hander) } }) }), b('runtime/html5/filepicker', ['base', 'runtime/html5/runtime'], function(a, b) {
        const c = a.$; return b.register('FilePicker', { init: function() {
            let a; let b; let d; let e; const f = this.getRuntime().getContainer(); const g = this; const h = g.owner; const i = g.options; const j = c(document.createElement('label')); let k = c(document.createElement('input')); if (k.attr('type', 'file'), k.attr('name', i.name), k.addClass('webuploader-element-invisible'), j.on('click', function() { k.trigger('click') }), j.css({ opacity: 0, width: '100%', height: '100%', display: 'block', cursor: 'pointer', background: '#ffffff' }), i.multiple && k.attr('multiple', 'multiple'), i.accept && i.accept.length > 0) { for (a = [], b = 0, d = i.accept.length; d > b; b++)a.push(i.accept[b].mimeTypes); k.attr('accept', a.join(',')) }f.append(k), f.append(j), e = function(a) { h.trigger(a.type) }, k.on('change', function(a) {
                let b; const d = arguments.callee; g.files = a.target.files, b = this.cloneNode(!0), this.parentNode.replaceChild(b, this), k.off(), k = c(b).on('change', d)
                    .on('mouseenter mouseleave', e), h.trigger('change')
            }), j.on('mouseenter mouseleave', e)
        }, getFiles: function() { return this.files }, destroy: function() {} })
    }), b('runtime/html5/util', ['base'], function(b) { const c = a.createObjectURL && a || a.URL && URL.revokeObjectURL && URL || a.webkitURL; let d = b.noop; let e = d; return c && (d = function() { return c.createObjectURL.apply(c, arguments) }, e = function() { return c.revokeObjectURL.apply(c, arguments) }), { createObjectURL: d, revokeObjectURL: e, dataURL2Blob: function(a) { let b, c, d, e, f, g; for (g = a.split(','), b = ~g[0].indexOf('base64') ? atob(g[1]) : decodeURIComponent(g[1]), d = new ArrayBuffer(b.length), c = new Uint8Array(d), e = 0; e < b.length; e++)c[e] = b.charCodeAt(e); return f = g[0].split(':')[1].split(';')[0], this.arrayBufferToBlob(d, f) }, dataURL2ArrayBuffer: function(a) { let b, c, d, e; for (e = a.split(','), b = ~e[0].indexOf('base64') ? atob(e[1]) : decodeURIComponent(e[1]), c = new Uint8Array(b.length), d = 0; d < b.length; d++)c[d] = b.charCodeAt(d); return c.buffer }, arrayBufferToBlob: function(b, c) { let d; const e = a.BlobBuilder || a.WebKitBlobBuilder; return e ? (d = new e(), d.append(b), d.getBlob(c)) : new Blob([b], c ? { type: c } : {}) }, canvasToDataUrl: function(a, b, c) { return a.toDataURL(b, c / 100) }, parseMeta: function(a, b) { b(!1, {}) }, updateImageHead: function(a) { return a } } }), b('runtime/html5/imagemeta', ['runtime/html5/util'], function(a) { let b; return b = { parsers: { 65505: [] }, maxMetaDataSize: 262144, parse: function(a, b) { const c = this; let d = new FileReader(); d.onload = function() { b(!1, c._parse(this.result)), d = d.onload = d.onerror = null }, d.onerror = function(a) { b(a.message), d = d.onload = d.onerror = null }, a = a.slice(0, c.maxMetaDataSize), d.readAsArrayBuffer(a.getSource()) }, _parse: function(a, c) { if (!(a.byteLength < 6)) { let d; let e; let f; let g; const h = new DataView(a); let i = 2; const j = h.byteLength - 4; let k = i; const l = {}; if (h.getUint16(0) === 65496) { for (;j > i && (d = h.getUint16(i), d >= 65504 && d <= 65519 || d === 65534) && (e = h.getUint16(i + 2) + 2, !(i + e > h.byteLength));) { if (f = b.parsers[d], !c && f) for (g = 0; g < f.length; g += 1)f[g].call(b, h, i, e, l); i += e, k = i }k > 6 && (l.imageHead = a.slice ? a.slice(2, k) : new Uint8Array(a).subarray(2, k)) } return l } }, updateImageHead: function(a, b) { let c; let d; let e; const f = this._parse(a, !0); return e = 2, f.imageHead && (e = 2 + f.imageHead.byteLength), d = a.slice ? a.slice(e) : new Uint8Array(a).subarray(e), c = new Uint8Array(b.byteLength + 2 + d.byteLength), c[0] = 255, c[1] = 216, c.set(new Uint8Array(b), 2), c.set(new Uint8Array(d), b.byteLength + 2), c.buffer } }, a.parseMeta = function() { return b.parse.apply(b, arguments) }, a.updateImageHead = function() { return b.updateImageHead.apply(b, arguments) }, b }), b('runtime/html5/imagemeta/exif', ['base', 'runtime/html5/imagemeta'], function(a, b) { const c = {}; return c.ExifMap = function() { return this }, c.ExifMap.prototype.map = { Orientation: 274 }, c.ExifMap.prototype.get = function(a) { return this[a] || this[this.map[a]] }, c.exifTagTypes = { 1: { getValue: function(a, b) { return a.getUint8(b) }, size: 1 }, 2: { getValue: function(a, b) { return String.fromCharCode(a.getUint8(b)) }, size: 1, ascii: !0 }, 3: { getValue: function(a, b, c) { return a.getUint16(b, c) }, size: 2 }, 4: { getValue: function(a, b, c) { return a.getUint32(b, c) }, size: 4 }, 5: { getValue: function(a, b, c) { return a.getUint32(b, c) / a.getUint32(b + 4, c) }, size: 8 }, 9: { getValue: function(a, b, c) { return a.getInt32(b, c) }, size: 4 }, 10: { getValue: function(a, b, c) { return a.getInt32(b, c) / a.getInt32(b + 4, c) }, size: 8 } }, c.exifTagTypes[7] = c.exifTagTypes[1], c.getExifValue = function(b, d, e, f, g, h) { let i; let j; let k; let l; let m; let n; const o = c.exifTagTypes[f]; if (!o) return void a.log('Invalid Exif data: Invalid tag type.'); if (i = o.size * g, j = i > 4 ? d + b.getUint32(e + 8, h) : e + 8, j + i > b.byteLength) return void a.log('Invalid Exif data: Invalid data offset.'); if (g === 1) return o.getValue(b, j, h); for (k = [], l = 0; g > l; l += 1)k[l] = o.getValue(b, j + l * o.size, h); if (o.ascii) { for (m = '', l = 0; l < k.length && (n = k[l], n !== '\x00'); l += 1)m += n; return m } return k }, c.parseExifTag = function(a, b, d, e, f) { const g = a.getUint16(d, e); f.exif[g] = c.getExifValue(a, b, d, a.getUint16(d + 2, e), a.getUint32(d + 4, e), e) }, c.parseExifTags = function(b, c, d, e, f) { let g, h, i; if (d + 6 > b.byteLength) return void a.log('Invalid Exif data: Invalid directory offset.'); if (g = b.getUint16(d, e), h = d + 2 + 12 * g, h + 4 > b.byteLength) return void a.log('Invalid Exif data: Invalid directory size.'); for (i = 0; g > i; i += 1) this.parseExifTag(b, c, d + 2 + 12 * i, e, f); return b.getUint32(h, e) }, c.parseExifData = function(b, d, e, f) { let g; let h; const i = d + 10; if (b.getUint32(d + 4) === 1165519206) { if (i + 8 > b.byteLength) return void a.log('Invalid Exif data: Invalid segment size.'); if (b.getUint16(d + 8) !== 0) return void a.log('Invalid Exif data: Missing byte alignment offset.'); switch (b.getUint16(i)) { case 18761:g = !0; break; case 19789:g = !1; break; default:return void a.log('Invalid Exif data: Invalid byte alignment marker.') } if (b.getUint16(i + 2, g) !== 42) return void a.log('Invalid Exif data: Missing TIFF marker.'); h = b.getUint32(i + 4, g), f.exif = new c.ExifMap(), h = c.parseExifTags(b, i, i + h, g, f) } }, b.parsers[65505].push(c.parseExifData), c }), b('runtime/html5/jpegencoder', [], function() { function a(a) { function b(a) { for (let b = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], c = 0; c < 64; c++) { let d = y((b[c] * a + 50) / 100); d < 1 ? d = 1 : d > 255 && (d = 255), z[P[c]] = d } for (let e = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], f = 0; f < 64; f++) { let g = y((e[f] * a + 50) / 100); g < 1 ? g = 1 : g > 255 && (g = 255), A[P[f]] = g } for (let h = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], i = 0, j = 0; j < 8; j++) for (let k = 0; k < 8; k++)B[i] = 1 / (z[P[i]] * h[j] * h[k] * 8), C[i] = 1 / (A[P[i]] * h[j] * h[k] * 8), i++ } function c(a, b) { for (var c = 0, d = 0, e = new Array(), f = 1; f <= 16; f++) { for (let g = 1; g <= a[f]; g++)e[b[d]] = [], e[b[d]][0] = c, e[b[d]][1] = f, d++, c++; c *= 2 } return e } function d() { t = c(Q, R), u = c(U, V), v = c(S, T), w = c(W, X) } function e() { for (let a = 1, b = 2, c = 1; c <= 15; c++) { for (let d = a; b > d; d++)E[32767 + d] = c, D[32767 + d] = [], D[32767 + d][1] = c, D[32767 + d][0] = d; for (let e = -(b - 1); -a >= e; e++)E[32767 + e] = c, D[32767 + e] = [], D[32767 + e][1] = c, D[32767 + e][0] = b - 1 + e; a <<= 1, b <<= 1 } } function f() { for (let a = 0; a < 256; a++)O[a] = 19595 * a, O[a + 256 >> 0] = 38470 * a, O[a + 512 >> 0] = 7471 * a + 32768, O[a + 768 >> 0] = -11059 * a, O[a + 1024 >> 0] = -21709 * a, O[a + 1280 >> 0] = 32768 * a + 8421375, O[a + 1536 >> 0] = -27439 * a, O[a + 1792 >> 0] = -5329 * a } function g(a) { for (let b = a[0], c = a[1] - 1; c >= 0;)b & 1 << c && (I |= 1 << J), c--, J--, J < 0 && (I == 255 ? (h(255), h(0)) : h(I), J = 7, I = 0) } function h(a) { H.push(N[a]) } function i(a) { h(a >> 8 & 255), h(255 & a) } function j(a, b) { let c; let d; let e; let f; let g; let h; let i; let j; let k; let l = 0; const m = 8; const n = 64; for (k = 0; m > k; ++k) { c = a[l], d = a[l + 1], e = a[l + 2], f = a[l + 3], g = a[l + 4], h = a[l + 5], i = a[l + 6], j = a[l + 7]; const o = c + j; const p = c - j; const q = d + i; const r = d - i; const s = e + h; const t = e - h; const u = f + g; const v = f - g; let w = o + u; const x = o - u; let y = q + s; let z = q - s; a[l] = w + y, a[l + 4] = w - y; const A = 0.707106781 * (z + x); a[l + 2] = x + A, a[l + 6] = x - A, w = v + t, y = t + r, z = r + p; const B = 0.382683433 * (w - z); const C = 0.5411961 * w + B; const D = 1.306562965 * z + B; const E = 0.707106781 * y; const G = p + E; const H = p - E; a[l + 5] = H + C, a[l + 3] = H - C, a[l + 1] = G + D, a[l + 7] = G - D, l += 8 } for (l = 0, k = 0; m > k; ++k) { c = a[l], d = a[l + 8], e = a[l + 16], f = a[l + 24], g = a[l + 32], h = a[l + 40], i = a[l + 48], j = a[l + 56]; const I = c + j; const J = c - j; const K = d + i; const L = d - i; const M = e + h; const N = e - h; const O = f + g; const P = f - g; let Q = I + O; const R = I - O; let S = K + M; let T = K - M; a[l] = Q + S, a[l + 32] = Q - S; const U = 0.707106781 * (T + R); a[l + 16] = R + U, a[l + 48] = R - U, Q = P + N, S = N + L, T = L + J; const V = 0.382683433 * (Q - T); const W = 0.5411961 * Q + V; const X = 1.306562965 * T + V; const Y = 0.707106781 * S; const Z = J + Y; const $ = J - Y; a[l + 40] = $ + W, a[l + 24] = $ - W, a[l + 8] = Z + X, a[l + 56] = Z - X, l++ } let _; for (k = 0; n > k; ++k)_ = a[k] * b[k], F[k] = _ > 0 ? _ + 0.5 | 0 : _ - 0.5 | 0; return F } function k() { i(65504), i(16), h(74), h(70), h(73), h(70), h(0), h(1), h(1), h(0), i(1), i(1), h(0), h(0) } function l(a, b) { i(65472), i(17), h(8), i(b), i(a), h(3), h(1), h(17), h(0), h(2), h(17), h(1), h(3), h(17), h(1) } function m() { i(65499), i(132), h(0); for (let a = 0; a < 64; a++)h(z[a]); h(1); for (let b = 0; b < 64; b++)h(A[b]) } function n() { i(65476), i(418), h(0); for (let a = 0; a < 16; a++)h(Q[a + 1]); for (let b = 0; b <= 11; b++)h(R[b]); h(16); for (let c = 0; c < 16; c++)h(S[c + 1]); for (let d = 0; d <= 161; d++)h(T[d]); h(1); for (let e = 0; e < 16; e++)h(U[e + 1]); for (let f = 0; f <= 11; f++)h(V[f]); h(17); for (let g = 0; g < 16; g++)h(W[g + 1]); for (let j = 0; j <= 161; j++)h(X[j]) } function o() { i(65498), i(12), h(3), h(1), h(0), h(2), h(17), h(3), h(17), h(0), h(63), h(0) } function p(a, b, c, d, e) { for (var f, h = e[0], i = e[240], k = 16, l = 63, m = 64, n = j(a, b), o = 0; m > o; ++o)G[P[o]] = n[o]; const p = G[0] - c; c = G[0], p == 0 ? g(d[0]) : (f = 32767 + p, g(d[E[f]]), g(D[f])); for (var q = 63; q > 0 && G[q] == 0; q--);if (q == 0) return g(h), c; for (var r, s = 1; q >= s;) { for (var t = s; G[s] == 0 && q >= s; ++s);let u = s - t; if (u >= k) { r = u >> 4; for (let v = 1; r >= v; ++v)g(i); u = 15 & u }f = 32767 + G[s], g(e[(u << 4) + E[f]]), g(D[f]), s++ } return q != l && g(h), c } function q() { for (let a = String.fromCharCode, b = 0; b < 256; b++)N[b] = a(b) } function r(a) { if (a <= 0 && (a = 1), a > 100 && (a = 100), x != a) { let c = 0; c = Math.floor(a < 50 ? 5e3 / a : 200 - 2 * a), b(c), x = a } } function s() { a || (a = 50), q(), d(), e(), f(), r(a) } let t; let u; let v; let w; let x; var y = (Math.round, Math.floor); var z = new Array(64); var A = new Array(64); var B = new Array(64); var C = new Array(64); var D = new Array(65535); var E = new Array(65535); var F = new Array(64); var G = new Array(64); var H = []; var I = 0; var J = 7; const K = new Array(64); const L = new Array(64); const M = new Array(64); var N = new Array(256); var O = new Array(2048); var P = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63]; var Q = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]; var R = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; var S = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125]; var T = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250]; var U = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]; var V = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; var W = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119]; var X = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250]; this.encode = function(a, b) { b && r(b), H = new Array(), I = 0, J = 7, i(65496), k(), m(), l(a.width, a.height), n(), o(); let c = 0; let d = 0; let e = 0; I = 0, J = 7, this.encode.displayName = '_encode_'; for (var f, h, j, q, s, x, y, z, A, D = a.data, E = a.width, F = a.height, G = 4 * E, N = 0; F > N;) { for (f = 0; G > f;) { for (s = G * N + f, x = s, y = -1, z = 0, A = 0; A < 64; A++)z = A >> 3, y = 4 * (7 & A), x = s + z * G + y, N + z >= F && (x -= G * (N + 1 + z - F)), f + y >= G && (x -= f + y - G + 4), h = D[x++], j = D[x++], q = D[x++], K[A] = (O[h] + O[j + 256 >> 0] + O[q + 512 >> 0] >> 16) - 128, L[A] = (O[h + 768 >> 0] + O[j + 1024 >> 0] + O[q + 1280 >> 0] >> 16) - 128, M[A] = (O[h + 1280 >> 0] + O[j + 1536 >> 0] + O[q + 1792 >> 0] >> 16) - 128; c = p(K, B, c, t, v), d = p(L, C, d, u, w), e = p(M, C, e, u, w), f += 32 }N += 8 } if (J >= 0) { const P = []; P[1] = J + 1, P[0] = (1 << J + 1) - 1, g(P) }i(65497); const Q = 'data:image/jpeg;base64,' + btoa(H.join('')); return H = [], Q }, s() } return a.encode = function(b, c) { const d = new a(c); return d.encode(b) }, a }), b('runtime/html5/androidpatch', ['runtime/html5/util', 'runtime/html5/jpegencoder', 'base'], function(a, b, c) { let d; const e = a.canvasToDataUrl; a.canvasToDataUrl = function(a, f, g) { let h, i, j, k, l; return c.os.android ? (f === 'image/jpeg' && typeof d === 'undefined' && (k = e.apply(null, arguments), l = k.split(','), k = ~l[0].indexOf('base64') ? atob(l[1]) : decodeURIComponent(l[1]), k = k.substring(0, 2), d = k.charCodeAt(0) === 255 && k.charCodeAt(1) === 216), f !== 'image/jpeg' || d ? e.apply(null, arguments) : (i = a.width, j = a.height, h = a.getContext('2d'), b.encode(h.getImageData(0, 0, i, j), g))) : e.apply(null, arguments) } }), b('runtime/html5/image', ['base', 'runtime/html5/runtime', 'runtime/html5/util'], function(a, b, c) { const d = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D'; return b.register('Image', { modified: !1, init: function() { const a = this; const b = new Image(); b.onload = function() { a._info = { type: a.type, width: this.width, height: this.height }, a._metas || a.type !== 'image/jpeg' ? a.owner.trigger('load') : c.parseMeta(a._blob, function(b, c) { a._metas = c, a.owner.trigger('load') }) }, b.onerror = function() { a.owner.trigger('error') }, a._img = b }, loadFromBlob: function(a) { const b = this; const d = b._img; b._blob = a, b.type = a.type, d.src = c.createObjectURL(a.getSource()), b.owner.once('load', function() { c.revokeObjectURL(d.src) }) }, resize: function(a, b) { const c = this._canvas || (this._canvas = document.createElement('canvas')); this._resize(this._img, c, a, b), this._blob = null, this.modified = !0, this.owner.trigger('complete') }, getAsBlob: function(a) { let b; let d = this._blob; const e = this.options; if (a = a || this.type, this.modified || this.type !== a) { if (b = this._canvas, a === 'image/jpeg') { if (d = c.canvasToDataUrl(b, 'image/jpeg', e.quality), e.preserveHeaders && this._metas && this._metas.imageHead) return d = c.dataURL2ArrayBuffer(d), d = c.updateImageHead(d, this._metas.imageHead), d = c.arrayBufferToBlob(d, a) } else d = c.canvasToDataUrl(b, a); d = c.dataURL2Blob(d) } return d }, getAsDataUrl: function(a) { const b = this.options; return a = a || this.type, a === 'image/jpeg' ? c.canvasToDataUrl(this._canvas, a, b.quality) : this._canvas.toDataURL(a) }, getOrientation: function() { return this._metas && this._metas.exif && this._metas.exif.get('Orientation') || 1 }, info: function(a) { return a ? (this._info = a, this) : this._info }, meta: function(a) { return a ? (this._meta = a, this) : this._meta }, destroy: function() { const a = this._canvas; this._img.onload = null, a && (a.getContext('2d').clearRect(0, 0, a.width, a.height), a.width = a.height = 0, this._canvas = null), this._img.src = d, this._img = this._blob = null }, _resize: function(a, b, c, d) { let e; let f; let g; let h; let i; const j = this.options; const k = a.width; const l = a.height; const m = this.getOrientation(); ~[5, 6, 7, 8].indexOf(m) && (c ^= d, d ^= c, c ^= d), e = Math[j.crop ? 'max' : 'min'](c / k, d / l), j.allowMagnify || (e = Math.min(1, e)), f = k * e, g = l * e, j.crop ? (b.width = c, b.height = d) : (b.width = f, b.height = g), h = (b.width - f) / 2, i = (b.height - g) / 2, j.preserveHeaders || this._rotate2Orientaion(b, m), this._renderImageToCanvas(b, a, h, i, f, g) }, _rotate2Orientaion: function(a, b) { const c = a.width; const d = a.height; const e = a.getContext('2d'); switch (b) { case 5:case 6:case 7:case 8:a.width = d, a.height = c } switch (b) { case 2:e.translate(c, 0), e.scale(-1, 1); break; case 3:e.translate(c, d), e.rotate(Math.PI); break; case 4:e.translate(0, d), e.scale(1, -1); break; case 5:e.rotate(0.5 * Math.PI), e.scale(1, -1); break; case 6:e.rotate(0.5 * Math.PI), e.translate(0, -d); break; case 7:e.rotate(0.5 * Math.PI), e.translate(c, -d), e.scale(-1, 1); break; case 8:e.rotate(-0.5 * Math.PI), e.translate(-c, 0) } }, _renderImageToCanvas: (function() { function b(a, b, c) { let d; let e; let f; const g = document.createElement('canvas'); const h = g.getContext('2d'); let i = 0; let j = c; let k = c; for (g.width = 1, g.height = c, h.drawImage(a, 0, 0), d = h.getImageData(0, 0, 1, c).data; k > i;)e = d[4 * (k - 1) + 3], e === 0 ? j = k : i = k, k = j + i >> 1; return f = k / c, f === 0 ? 1 : f } function c(a) { let b; let c; const d = a.naturalWidth; const e = a.naturalHeight; return d * e > 1048576 ? (b = document.createElement('canvas'), b.width = b.height = 1, c = b.getContext('2d'), c.drawImage(a, -d + 1, 0), c.getImageData(0, 0, 1, 1).data[3] === 0) : !1 } return a.os.ios ? a.os.ios >= 7 ? function(a, c, d, e, f, g) { const h = c.naturalWidth; const i = c.naturalHeight; const j = b(c, h, i); return a.getContext('2d').drawImage(c, 0, 0, h * j, i * j, d, e, f, g) } : function(a, d, e, f, g, h) { let i; let j; let k; let l; let m; let n; let o; let p = d.naturalWidth; let q = d.naturalHeight; const r = a.getContext('2d'); const s = c(d); const t = this.type === 'image/jpeg'; const u = 1024; let v = 0; let w = 0; for (s && (p /= 2, q /= 2), r.save(), i = document.createElement('canvas'), i.width = i.height = u, j = i.getContext('2d'), k = t ? b(d, p, q) : 1, l = Math.ceil(u * g / p), m = Math.ceil(u * h / q / k); q > v;) { for (n = 0, o = 0; p > n;)j.clearRect(0, 0, u, u), j.drawImage(d, -n, -v), r.drawImage(i, 0, 0, u, u, e + o, f + w, l, m), n += u, o += l; v += u, w += m }r.restore(), i = j = null } : function(a, b, c, d, e, f) { a.getContext('2d').drawImage(b, c, d, e, f) } }()) }) }), b('runtime/html5/transport', ['base', 'runtime/html5/runtime'], function(a, b) { const c = a.noop; const d = a.$; return b.register('Transport', { init: function() { this._status = 0, this._response = null }, send: function() { let b; let c; let e; const f = this.owner; const g = this.options; const h = this._initAjax(); const i = f._blob; let j = g.server; g.sendAsBinary ? (j += (/\?/.test(j) ? '&' : '?') + d.param(f._formData), c = i.getSource()) : (b = new FormData(), d.each(f._formData, function(a, c) { b.append(a, c) }), b.append(g.fileVal, i.getSource(), g.filename || f._formData.name || '')), g.withCredentials && 'withCredentials' in h ? (h.open(g.method, j, !0), h.withCredentials = !0) : h.open(g.method, j), this._setRequestHeader(h, g.headers), c ? (h.overrideMimeType('application/octet-stream'), a.os.android ? (e = new FileReader(), e.onload = function() { h.send(this.result), e = e.onload = null }, e.readAsArrayBuffer(c)) : h.send(c)) : h.send(b) }, getResponse: function() { return this._response }, getResponseAsJson: function() { return this._parseJson(this._response) }, getStatus: function() { return this._status }, abort: function() { let a = this._xhr; a && (a.upload.onprogress = c, a.onreadystatechange = c, a.abort(), this._xhr = a = null) }, destroy: function() { this.abort() }, _initAjax: function() { const a = this; let b = new XMLHttpRequest(); const d = this.options; return !d.withCredentials || 'withCredentials' in b || typeof XDomainRequest === 'undefined' || (b = new XDomainRequest()), b.upload.onprogress = function(b) { let c = 0; return b.lengthComputable && (c = b.loaded / b.total), a.trigger('progress', c) }, b.onreadystatechange = function() { return b.readyState === 4 ? (b.upload.onprogress = c, b.onreadystatechange = c, a._xhr = null, a._status = b.status, b.status >= 200 && b.status < 300 ? (a._response = b.responseText, a.trigger('load')) : b.status >= 500 && b.status < 600 ? (a._response = b.responseText, a.trigger('error', 'server')) : a.trigger('error', a._status ? 'http' : 'abort')) : void 0 }, a._xhr = b, b }, _setRequestHeader: function(a, b) { d.each(b, function(b, c) { a.setRequestHeader(b, c) }) }, _parseJson: function(a) { let b; try { b = JSON.parse(a) } catch (c) { b = {} } return b } }) }), b('runtime/flash/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function(b, c, d) { function e() { let a; try { a = navigator.plugins['Shockwave Flash'], a = a.description } catch (b) { try { a = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version') } catch (c) { a = '0.0' } } return a = a.match(/\d+/g), parseFloat(a[0] + '.' + a[1], 10) } function f() { function d(a, b) { let c; let d; let e = a.type || a; c = e.split('::'), d = c[0], e = c[1], e === 'Ready' && d === j.uid ? j.trigger('ready') : f[d] && f[d].trigger(e.toLowerCase(), a, b) } const e = {}; var f = {}; const g = this.destory; var j = this; const k = b.guid('webuploader_'); c.apply(j, arguments), j.type = h, j.exec = function(a, c) { let d; const g = this; const h = g.uid; const k = b.slice(arguments, 2); return f[h] = g, i[a] && (e[h] || (e[h] = new i[a](g, j)), d = e[h], d[c]) ? d[c].apply(d, k) : j.flashExec.apply(g, arguments) }, a[k] = function() { const a = arguments; setTimeout(function() { d.apply(null, a) }, 1) }, this.jsreciver = k, this.destory = function() { return g && g.apply(this, arguments) }, this.flashExec = function(a, c) { const d = j.getFlash(); const e = b.slice(arguments, 2); return d.exec(this.uid, a, c, e) } } const g = b.$; var h = 'flash'; var i = {}; return b.inherits(c, { constructor: f, init: function() { let a; const c = this.getContainer(); const d = this.options; c.css({ position: 'absolute', top: '-8px', left: '-8px', width: '9px', height: '9px', overflow: 'hidden' }), a = '<object id="' + this.uid + '" type="application/x-shockwave-flash" data="' + d.swf + '" ', b.browser.ie && (a += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '), a += 'width="100%" height="100%" style="outline:0"><param name="movie" value="' + d.swf + '" /><param name="flashvars" value="uid=' + this.uid + '&jsreciver=' + this.jsreciver + '" /><param name="wmode" value="transparent" /><param name="allowscriptaccess" value="always" /></object>', c.html(a) }, getFlash: function() { return this._flash ? this._flash : (this._flash = g('#' + this.uid).get(0), this._flash) } }), f.register = function(a, c) { return c = i[a] = b.inherits(d, g.extend({ flashExec: function() { const a = this.owner; const b = this.getRuntime(); return b.flashExec.apply(a, arguments) } }, c)) }, e() >= 11.4 && c.addRuntime(h, f), f }), b('runtime/flash/filepicker', ['base', 'runtime/flash/runtime'], function(a, b) { const c = a.$; return b.register('FilePicker', { init: function(a) { let b; let d; const e = c.extend({}, a); for (b = e.accept && e.accept.length, d = 0; b > d; d++)e.accept[d].title || (e.accept[d].title = 'Files'); delete e.button, delete e.container, this.flashExec('FilePicker', 'init', e) }, destroy: function() {} }) }), b('runtime/flash/image', ['runtime/flash/runtime'], function(a) { return a.register('Image', { loadFromBlob: function(a) { const b = this.owner; b.info() && this.flashExec('Image', 'info', b.info()), b.meta() && this.flashExec('Image', 'meta', b.meta()), this.flashExec('Image', 'loadFromBlob', a.uid) } }) }), b('runtime/flash/transport', ['base', 'runtime/flash/runtime', 'runtime/client'], function(a, b, c) { const d = a.$; return b.register('Transport', { init: function() { this._status = 0, this._response = null, this._responseJson = null }, send: function() { let a; const b = this.owner; const c = this.options; const e = this._initAjax(); const f = b._blob; let g = c.server; e.connectRuntime(f.ruid), c.sendAsBinary ? (g += (/\?/.test(g) ? '&' : '?') + d.param(b._formData), a = f.uid) : (d.each(b._formData, function(a, b) { e.exec('append', a, b) }), e.exec('appendBlob', c.fileVal, f.uid, c.filename || b._formData.name || '')), this._setRequestHeader(e, c.headers), e.exec('send', { method: c.method, url: g }, a) }, getStatus: function() { return this._status }, getResponse: function() { return this._response }, getResponseAsJson: function() { return this._responseJson }, abort: function() { let a = this._xhr; a && (a.exec('abort'), a.destroy(), this._xhr = a = null) }, destroy: function() { this.abort() }, _initAjax: function() { const a = this; let b = new c('XMLHttpRequest'); return b.on('uploadprogress progress', function(b) { return a.trigger('progress', b.loaded / b.total) }), b.on('load', function() { const c = b.exec('getStatus'); let d = ''; return b.off(), a._xhr = null, c >= 200 && c < 300 ? (a._response = b.exec('getResponse'), a._responseJson = b.exec('getResponseAsJson')) : c >= 500 && c < 600 ? (a._response = b.exec('getResponse'), a._responseJson = b.exec('getResponseAsJson'), d = 'server') : d = 'http', b.destroy(), b = null, d ? a.trigger('error', d) : a.trigger('load') }), b.on('error', function() { b.off(), a._xhr = null, a.trigger('error', 'http') }), a._xhr = b, b }, _setRequestHeader: function(a, b) { d.each(b, function(b, c) { a.exec('setRequestHeader', b, c) }) } }) }), b('preset/all', ['base', 'widgets/filednd', 'widgets/filepaste', 'widgets/filepicker', 'widgets/image', 'widgets/queue', 'widgets/runtime', 'widgets/upload', 'widgets/validator', 'runtime/html5/blob', 'runtime/html5/dnd', 'runtime/html5/filepaste', 'runtime/html5/filepicker', 'runtime/html5/imagemeta/exif', 'runtime/html5/androidpatch', 'runtime/html5/image', 'runtime/html5/transport', 'runtime/flash/filepicker', 'runtime/flash/image', 'runtime/flash/transport'], function(a) { return a }), b('webuploader', ['preset/all'], function(a) { return a }), c('webuploader')
}))
