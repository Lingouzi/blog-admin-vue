/* WebUploader 0.1.2 */!(function(a, b) { let c; const d = {}; const e = function(a, b) { let c, d, e; if (typeof a === 'string') return h(a); for (c = [], d = a.length, e = 0; d > e; e++)c.push(h(a[e])); return b.apply(null, c) }; const f = function(a, b, c) { arguments.length === 2 && (c = b, b = null), e(b || [], function() { g(a, c, arguments) }) }; var g = function(a, b, c) { let f; const g = { exports: b }; typeof b === 'function' && (c.length || (c = [e, g.exports, g]), f = b.apply(null, c), void 0 !== f && (g.exports = f)), d[a] = g.exports }; var h = function(b) { const c = d[b] || a[b]; if (!c) throw new Error('`' + b + '` is undefined'); return c }; const i = function(a) { let b, c, e, f, g, h; h = function(a) { return a && a.charAt(0).toUpperCase() + a.substr(1) }; for (b in d) if (c = a, d.hasOwnProperty(b)) { for (e = b.split('/'), g = h(e.pop()); f = h(e.shift());)c[f] = c[f] || {}, c = c[f]; c[g] = d[b] } }; const j = b(a, f, e); i(j), typeof module === 'object' && typeof module.exports === 'object' ? module.exports = j : typeof define === 'function' && define.amd ? define([], j) : (c = a.WebUploader, a.WebUploader = j, a.WebUploader.noConflict = function() { a.WebUploader = c }) }(this, function(a, b, c) {
    return b('dollar-third', [], function() { return a.jQuery || a.Zepto }), b('dollar', ['dollar-third'], function(a) { return a }), b('promise-third', ['dollar'], function(a) { return { Deferred: a.Deferred, when: a.when, isPromise: function(a) { return a && typeof a.then === 'function' } } }), b('promise', ['promise-third'], function(a) { return a }), b('base', ['dollar', 'promise'], function(b, c) { function d(a) { return function() { return h.apply(a, arguments) } } function e(a, b) { return function() { return a.apply(b, arguments) } } function f(a) { let b; return Object.create ? Object.create(a) : (b = function() {}, b.prototype = a, new b()) } const g = function() {}; var h = Function.call; return { version: '0.1.2', $: b, Deferred: c.Deferred, isPromise: c.isPromise, when: c.when, browser: (function(a) { const b = {}; const c = a.match(/WebKit\/([\d.]+)/); const d = a.match(/Chrome\/([\d.]+)/) || a.match(/CriOS\/([\d.]+)/); const e = a.match(/MSIE\s([\d\.]+)/) || a.match(/(?:trident)(?:.*rv:([\w.]+))?/i); const f = a.match(/Firefox\/([\d.]+)/); const g = a.match(/Safari\/([\d.]+)/); const h = a.match(/OPR\/([\d.]+)/); return c && (b.webkit = parseFloat(c[1])), d && (b.chrome = parseFloat(d[1])), e && (b.ie = parseFloat(e[1])), f && (b.firefox = parseFloat(f[1])), g && (b.safari = parseFloat(g[1])), h && (b.opera = parseFloat(h[1])), b }(navigator.userAgent)), os: (function(a) { const b = {}; const c = a.match(/(?:Android);?[\s\/]+([\d.]+)?/); const d = a.match(/(?:iPad|iPod|iPhone).*OS\s([\d_]+)/); return c && (b.android = parseFloat(c[1])), d && (b.ios = parseFloat(d[1].replace(/_/g, '.'))), b }(navigator.userAgent)), inherits: function(a, c, d) { let e; return typeof c === 'function' ? (e = c, c = null) : e = c && c.hasOwnProperty('constructor') ? c.constructor : function() { return a.apply(this, arguments) }, b.extend(!0, e, a, d || {}), e.__super__ = a.prototype, e.prototype = f(a.prototype), c && b.extend(!0, e.prototype, c), e }, noop: g, bindFn: e, log: (function() { return a.console ? e(console.log, console) : g }()), nextTick: (function() { return function(a) { setTimeout(a, 1) } }()), slice: d([].slice), guid: (function() { let a = 0; return function(b) { for (var c = (+new Date()).toString(32), d = 0; d < 5; d++)c += Math.floor(65535 * Math.random()).toString(32); return (b || 'wu_') + c + (a++).toString(32) } }()), formatSize: function(a, b, c) { let d; for (c = c || ['B', 'K', 'M', 'G', 'TB']; (d = c.shift()) && a > 1024;)a /= 1024; return (d === 'B' ? a : a.toFixed(b || 2)) + d } } }), b('mediator', ['base'], function(a) { function b(a, b, c, d) { return f.grep(a, function(a) { return !(!a || b && a.e !== b || c && a.cb !== c && a.cb._cb !== c || d && a.ctx !== d) }) } function c(a, b, c) { f.each((a || '').split(h), function(a, d) { c(d, b) }) } function d(a, b) { for (var c, d = !1, e = -1, f = a.length; ++e < f;) if (c = a[e], c.cb.apply(c.ctx2, b) === !1) { d = !0; break } return !d } let e; var f = a.$; const g = [].slice; var h = /\s+/; return e = { on: function(a, b, d) { let e; const f = this; return b ? (e = this._events || (this._events = []), c(a, b, function(a, b) { const c = { e: a }; c.cb = b, c.ctx = d, c.ctx2 = d || f, c.id = e.length, e.push(c) }), this) : this }, once: function(a, b, d) { const e = this; return b ? (c(a, b, function(a, b) { var c = function() { return e.off(a, c), b.apply(d || e, arguments) }; c._cb = b, e.on(a, c, d) }), e) : e }, off: function(a, d, e) { const g = this._events; return g ? a || d || e ? (c(a, d, function(a, c) { f.each(b(g, a, c, e), function() { delete g[this.id] }) }), this) : (this._events = [], this) : this }, trigger: function(a) { let c, e, f; return this._events && a ? (c = g.call(arguments, 1), e = b(this._events, a), f = b(this._events, 'all'), d(e, c) && d(f, arguments)) : this } }, f.extend({ installTo: function(a) { return f.extend(a, e) } }, e) }), b('uploader', ['base', 'mediator'], function(a, b) { function c(a) { this.options = d.extend(!0, {}, c.options, a), this._init(this.options) } var d = a.$; return c.options = {}, b.installTo(c.prototype), d.each({ upload: 'start-upload', stop: 'stop-upload', getFile: 'get-file', getFiles: 'get-files', addFile: 'add-file', addFiles: 'add-file', sort: 'sort-files', removeFile: 'remove-file', skipFile: 'skip-file', retry: 'retry', isInProgress: 'is-in-progress', makeThumb: 'make-thumb', getDimension: 'get-dimension', addButton: 'add-btn', getRuntimeType: 'get-runtime-type', refresh: 'refresh', disable: 'disable', enable: 'enable', reset: 'reset' }, function(a, b) { c.prototype[a] = function() { return this.request(b, arguments) } }), d.extend(c.prototype, { state: 'pending', _init: function(a) { const b = this; b.request('init', a, function() { b.state = 'ready', b.trigger('ready') }) }, option: function(a, b) { const c = this.options; return arguments.length > 1 ? void (d.isPlainObject(b) && d.isPlainObject(c[a]) ? d.extend(c[a], b) : c[a] = b) : a ? c[a] : c }, getStats: function() { const a = this.request('get-stats'); return { successNum: a.numOfSuccess, cancelNum: a.numOfCancel, invalidNum: a.numOfInvalid, uploadFailNum: a.numOfUploadFailed, queueNum: a.numOfQueue } }, trigger: function(a) { const c = [].slice.call(arguments, 1); const e = this.options; const f = 'on' + a.substring(0, 1).toUpperCase() + a.substring(1); return b.trigger.apply(this, arguments) === !1 || d.isFunction(e[f]) && e[f].apply(this, c) === !1 || d.isFunction(this[f]) && this[f].apply(this, c) === !1 || b.trigger.apply(b, [this, a].concat(c)) === !1 ? !1 : !0 }, request: a.noop }), a.create = c.create = function(a) { return new c(a) }, a.Uploader = c, c }), b('runtime/runtime', ['base', 'mediator'], function(a, b) { function c(b) { this.options = d.extend({ container: document.body }, b), this.uid = a.guid('rt_') } var d = a.$; const e = {}; const f = function(a) { for (const b in a) if (a.hasOwnProperty(b)) return b; return null }; return d.extend(c.prototype, { getContainer: function() { let a; let b; const c = this.options; return this._container ? this._container : (a = d(c.container || document.body), b = d(document.createElement('div')), b.attr('id', 'rt_' + this.uid), b.css({ position: 'absolute', top: '0px', left: '0px', width: '1px', height: '1px', overflow: 'hidden' }), a.append(b), a.addClass('webuploader-container'), this._container = b, b) }, init: a.noop, exec: a.noop, destroy: function() { this._container && this._container.parentNode.removeChild(this.__container), this.off() } }), c.orders = 'html5,flash', c.addRuntime = function(a, b) { e[a] = b }, c.hasRuntime = function(a) { return !!(a ? e[a] : f(e)) }, c.create = function(a, b) { let g, h; if (b = b || c.orders, d.each(b.split(/\s*,\s*/g), function() { return e[this] ? (g = this, !1) : void 0 }), g = g || f(e), !g) throw new Error('Runtime Error'); return h = new e[g](a) }, b.installTo(c.prototype), c }), b('runtime/client', ['base', 'mediator', 'runtime/runtime'], function(a, b, c) { function d(b, d) { let f; const g = a.Deferred(); this.uid = a.guid('client_'), this.runtimeReady = function(a) { return g.done(a) }, this.connectRuntime = function(b, h) { if (f) throw new Error('already connected!'); return g.done(h), typeof b === 'string' && e.get(b) && (f = e.get(b)), f = f || e.get(null, d), f ? (a.$.extend(f.options, b), f.__promise.then(g.resolve), f.__client++) : (f = c.create(b, b.runtimeOrder), f.__promise = g.promise(), f.once('ready', g.resolve), f.init(), e.add(f), f.__client = 1), d && (f.__standalone = d), f }, this.getRuntime = function() { return f }, this.disconnectRuntime = function() { f && (f.__client--, f.__client <= 0 && (e.remove(f), delete f.__promise, f.destroy()), f = null) }, this.exec = function() { if (f) { const c = a.slice(arguments); return b && c.unshift(b), f.exec.apply(this, c) } }, this.getRuid = function() { return f && f.uid }, this.destroy = (function(a) { return function() { a && a.apply(this, arguments), this.trigger('destroy'), this.off(), this.exec('destroy'), this.disconnectRuntime() } }(this.destroy)) } let e; return e = (function() { const a = {}; return { add: function(b) { a[b.uid] = b }, get: function(b, c) { let d; if (b) return a[b]; for (d in a) if (!c || !a[d].__standalone) return a[d]; return null }, remove: function(b) { delete a[b.uid] } } }()), b.installTo(d.prototype), d }), b('lib/dnd', ['base', 'mediator', 'runtime/client'], function(a, b, c) { function d(a) { a = this.options = e.extend({}, d.options, a), a.container = e(a.container), a.container.length && c.call(this, 'DragAndDrop') } var e = a.$; return d.options = { accept: null, disableGlobalDnd: !1 }, a.inherits(c, { constructor: d, init: function() { const a = this; a.connectRuntime(a.options, function() { a.exec('init'), a.trigger('ready') }) }, destroy: function() { this.disconnectRuntime() } }), b.installTo(d.prototype), d }), b('widgets/widget', ['base', 'uploader'], function(a, b) { function c(a) { if (!a) return !1; const b = a.length; const c = e.type(a); return a.nodeType === 1 && b ? !0 : c === 'array' || c !== 'function' && c !== 'string' && (b === 0 || typeof b === 'number' && b > 0 && b - 1 in a) } function d(a) { this.owner = a, this.options = a.options } var e = a.$; const f = b.prototype._init; const g = {}; const h = []; return e.extend(d.prototype, { init: a.noop, invoke: function(a, b) { const c = this.responseMap; return c && a in c && c[a] in this && e.isFunction(this[c[a]]) ? this[c[a]].apply(this, b) : g }, request: function() { return this.owner.request.apply(this.owner, arguments) } }), e.extend(b.prototype, { _init: function() { const a = this; const b = a._widgets = []; return e.each(h, function(c, d) { b.push(new d(a)) }), f.apply(a, arguments) }, request: function(b, d, e) { let f; let h; let i; let j; let k = 0; const l = this._widgets; const m = l.length; const n = []; const o = []; for (d = c(d) ? d : [d]; m > k; k++)f = l[k], h = f.invoke(b, d), h !== g && (a.isPromise(h) ? o.push(h) : n.push(h)); return e || o.length ? (i = a.when.apply(a, o), j = i.pipe ? 'pipe' : 'then', i[j](function() { const b = a.Deferred(); const c = arguments; return setTimeout(function() { b.resolve.apply(b, c) }, 1), b.promise() })[j](e || a.noop)) : n[0] } }), b.register = d.register = function(b, c) { let f; const g = { init: 'init' }; return arguments.length === 1 ? (c = b, c.responseMap = g) : c.responseMap = e.extend(g, b), f = a.inherits(d, c), h.push(f), f }, d }), b('widgets/filednd', ['base', 'uploader', 'lib/dnd', 'widgets/widget'], function(a, b, c) { const d = a.$; return b.options.dnd = '', b.register({ init: function(b) { if (b.dnd && this.request('predict-runtime-type') === 'html5') { let e; const f = this; const g = a.Deferred(); const h = d.extend({}, { disableGlobalDnd: b.disableGlobalDnd, container: b.dnd, accept: b.accept }); return e = new c(h), e.once('ready', g.resolve), e.on('drop', function(a) { f.request('add-file', [a]) }), e.on('accept', function(a) { return f.owner.trigger('dndAccept', a) }), e.init(), g.promise() } } }) }), b('lib/filepaste', ['base', 'mediator', 'runtime/client'], function(a, b, c) { function d(a) { a = this.options = e.extend({}, a), a.container = e(a.container || document.body), c.call(this, 'FilePaste') } var e = a.$; return a.inherits(c, { constructor: d, init: function() { const a = this; a.connectRuntime(a.options, function() { a.exec('init'), a.trigger('ready') }) }, destroy: function() { this.exec('destroy'), this.disconnectRuntime(), this.off() } }), b.installTo(d.prototype), d }), b('widgets/filepaste', ['base', 'uploader', 'lib/filepaste', 'widgets/widget'], function(a, b, c) { const d = a.$; return b.register({ init: function(b) { if (b.paste && this.request('predict-runtime-type') === 'html5') { let e; const f = this; const g = a.Deferred(); const h = d.extend({}, { container: b.paste, accept: b.accept }); return e = new c(h), e.once('ready', g.resolve), e.on('paste', function(a) { f.owner.request('add-file', [a]) }), e.init(), g.promise() } } }) }), b('lib/blob', ['base', 'runtime/client'], function(a, b) { function c(a, c) { const d = this; d.source = c, d.ruid = a, b.call(d, 'Blob'), this.uid = c.uid || this.uid, this.type = c.type || '', this.size = c.size || 0, a && d.connectRuntime(a) } return a.inherits(b, { constructor: c, slice: function(a, b) { return this.exec('slice', a, b) }, getSource: function() { return this.source } }), c }), b('lib/file', ['base', 'lib/blob'], function(a, b) { function c(a, c) { let f; b.apply(this, arguments), this.name = c.name || 'untitled' + d++, f = e.exec(c.name) ? RegExp.$1.toLowerCase() : '', !f && this.type && (f = /\/(jpg|jpeg|png|gif|bmp)$/i.exec(this.type) ? RegExp.$1.toLowerCase() : '', this.name += '.' + f), !this.type && ~'jpg,jpeg,png,gif,bmp'.indexOf(f) && (this.type = 'image/' + (f === 'jpg' ? 'jpeg' : f)), this.ext = f, this.lastModifiedDate = c.lastModifiedDate || (new Date()).toLocaleString() } var d = 1; var e = /\.([^.]+)$/; return a.inherits(b, c) }), b('lib/filepicker', ['base', 'runtime/client', 'lib/file'], function(b, c, d) {
        function e(a) { if (a = this.options = f.extend({}, e.options, a), a.container = f(a.id), !a.container.length) throw new Error('按钮指定错误'); a.innerHTML = a.innerHTML || a.label || a.container.html() || '', a.button = f(a.button || document.createElement('div')), a.button.html(a.innerHTML), a.container.html(a.button), c.call(this, 'FilePicker', !0) } var f = b.$; return e.options = { button: null, container: null, label: null, innerHTML: null, multiple: !0, accept: null, name: 'file' }, b.inherits(c, { constructor: e, init: function() { const b = this; const c = b.options; const e = c.button; e.addClass('webuploader-pick'), b.on('all', function(a) { let g; switch (a) { case 'mouseenter':e.addClass('webuploader-pick-hover'); break; case 'mouseleave':e.removeClass('webuploader-pick-hover'); break; case 'change':g = b.exec('getFiles'), b.trigger('select', f.map(g, function(a) { return a = new d(b.getRuid(), a), a._refer = c.container, a }), c.container) } }), b.connectRuntime(c, function() { b.refresh(), b.exec('init', c), b.trigger('ready') }), f(a).on('resize', function() { b.refresh() }) }, refresh: function() { const a = this.getRuntime().getContainer(); const b = this.options.button; const c = b.outerWidth ? b.outerWidth() : b.width(); const d = b.outerHeight ? b.outerHeight() : b.height(); const e = b.offset(); c && d && a.css({ bottom: 'auto', right: 'auto', width: c + 'px', height: d + 'px' }).offset(e) }, enable: function() { const a = this.options.button; a.removeClass('webuploader-pick-disable'), this.refresh() }, disable: function() {
            const a = this.options.button; this.getRuntime().getContainer()
                .css({ top: '-99999px' }), a.addClass('webuploader-pick-disable')
        }, destroy: function() { this.runtime && (this.exec('destroy'), this.disconnectRuntime()) } }), e
    }), b('widgets/filepicker', ['base', 'uploader', 'lib/filepicker', 'widgets/widget'], function(a, b, c) { const d = a.$; return d.extend(b.options, { pick: null, accept: null }), b.register({ 'add-btn': 'addButton', refresh: 'refresh', disable: 'disable', enable: 'enable' }, { init: function(a) { return this.pickers = [], a.pick && this.addButton(a.pick) }, refresh: function() { d.each(this.pickers, function() { this.refresh() }) }, addButton: function(b) { let e; let f; let g; const h = this; const i = h.options; const j = i.accept; if (b) return g = a.Deferred(), d.isPlainObject(b) || (b = { id: b }), e = d.extend({}, b, { accept: d.isPlainObject(j) ? [j] : j, swf: i.swf, runtimeOrder: i.runtimeOrder }), f = new c(e), f.once('ready', g.resolve), f.on('select', function(a) { h.owner.request('add-file', [a]) }), f.init(), this.pickers.push(f), g.promise() }, disable: function() { d.each(this.pickers, function() { this.disable() }) }, enable: function() { d.each(this.pickers, function() { this.enable() }) } }) }), b('file', ['base', 'mediator'], function(a, b) { function c() { return f + g++ } function d(a) { this.name = a.name || 'Untitled', this.size = a.size || 0, this.type = a.type || 'application', this.lastModifiedDate = a.lastModifiedDate || 1 * new Date(), this.id = c(), this.ext = h.exec(this.name) ? RegExp.$1 : '', this.statusText = '', i[this.id] = d.Status.INITED, this.source = a, this.loaded = 0, this.on('error', function(a) { this.setStatus(d.Status.ERROR, a) }) } const e = a.$; var f = 'WU_FILE_'; var g = 0; var h = /\.([^.]+)$/; var i = {}; return e.extend(d.prototype, { setStatus: function(a, b) { const c = i[this.id]; typeof b !== 'undefined' && (this.statusText = b), a !== c && (i[this.id] = a, this.trigger('statuschange', a, c)) }, getStatus: function() { return i[this.id] }, getSource: function() { return this.source }, destory: function() { delete i[this.id] } }), b.installTo(d.prototype), d.Status = { INITED: 'inited', QUEUED: 'queued', PROGRESS: 'progress', ERROR: 'error', COMPLETE: 'complete', CANCELLED: 'cancelled', INTERRUPT: 'interrupt', INVALID: 'invalid' }, d }), b('queue', ['base', 'mediator', 'file'], function(a, b, c) { function d() { this.stats = { numOfQueue: 0, numOfSuccess: 0, numOfCancel: 0, numOfProgress: 0, numOfUploadFailed: 0, numOfInvalid: 0 }, this._queue = [], this._map = {} } const e = a.$; const f = c.Status; return e.extend(d.prototype, { append: function(a) { return this._queue.push(a), this._fileAdded(a), this }, prepend: function(a) { return this._queue.unshift(a), this._fileAdded(a), this }, getFile: function(a) { return typeof a !== 'string' ? a : this._map[a] }, fetch: function(a) { let b; let c; const d = this._queue.length; for (a = a || f.QUEUED, b = 0; d > b; b++) if (c = this._queue[b], a === c.getStatus()) return c; return null }, sort: function(a) { typeof a === 'function' && this._queue.sort(a) }, getFiles: function() { for (var a, b = [].slice.call(arguments, 0), c = [], d = 0, f = this._queue.length; f > d; d++)a = this._queue[d], (!b.length || ~e.inArray(a.getStatus(), b)) && c.push(a); return c }, _fileAdded: function(a) { const b = this; const c = this._map[a.id]; c || (this._map[a.id] = a, a.on('statuschange', function(a, c) { b._onFileStatusChange(a, c) })), a.setStatus(f.QUEUED) }, _onFileStatusChange: function(a, b) { const c = this.stats; switch (b) { case f.PROGRESS:c.numOfProgress--; break; case f.QUEUED:c.numOfQueue--; break; case f.ERROR:c.numOfUploadFailed--; break; case f.INVALID:c.numOfInvalid-- } switch (a) { case f.QUEUED:c.numOfQueue++; break; case f.PROGRESS:c.numOfProgress++; break; case f.ERROR:c.numOfUploadFailed++; break; case f.COMPLETE:c.numOfSuccess++; break; case f.CANCELLED:c.numOfCancel++; break; case f.INVALID:c.numOfInvalid++ } } }), b.installTo(d.prototype), d }), b('widgets/queue', ['base', 'uploader', 'queue', 'file', 'lib/file', 'runtime/client', 'widgets/widget'], function(a, b, c, d, e, f) {
        const g = a.$; const h = /\.\w+$/; const i = d.Status; return b.register({ 'sort-files': 'sortFiles', 'add-file': 'addFiles', 'get-file': 'getFile', 'fetch-file': 'fetchFile', 'get-stats': 'getStats', 'get-files': 'getFiles', 'remove-file': 'removeFile', retry: 'retry', reset: 'reset', 'accept-file': 'acceptFile' }, { init: function(b) {
            let d; let e; let h; let i; let j; let k; let l; const m = this; if (g.isPlainObject(b.accept) && (b.accept = [b.accept]), b.accept) {
                for (j = [], h = 0, e = b.accept.length; e > h; h++)i = b.accept[h].extensions, i && j.push(i); j.length && (k = '\\.' + j.join(',').replace(/,/g, '$|\\.')
                    .replace(/\*/g, '.*') + '$'), m.accept = new RegExp(k, 'i')
            } return m.queue = new c(), m.stats = m.queue.stats, this.request('predict-runtime-type') === 'html5' ? (d = a.Deferred(), l = new f('Placeholder'), l.connectRuntime({ runtimeOrder: 'html5' }, function() { m._ruid = l.getRuid(), d.resolve() }), d.promise()) : void 0
        }, _wrapFile: function(a) { if (!(a instanceof d)) { if (!(a instanceof e)) { if (!this._ruid) throw new Error("Can't add external files."); a = new e(this._ruid, a) }a = new d(a) } return a }, acceptFile: function(a) { const b = !a || a.size < 6 || this.accept && h.exec(a.name) && !this.accept.test(a.name); return !b }, _addFile: function(a) { const b = this; return a = b._wrapFile(a), b.owner.trigger('beforeFileQueued', a) ? b.acceptFile(a) ? (b.queue.append(a), b.owner.trigger('fileQueued', a), a) : void b.owner.trigger('error', 'Q_TYPE_DENIED', a) : void 0 }, getFile: function(a) { return this.queue.getFile(a) }, addFiles: function(a) { const b = this; a.length || (a = [a]), a = g.map(a, function(a) { return b._addFile(a) }), b.owner.trigger('filesQueued', a), b.options.auto && b.request('start-upload') }, getStats: function() { return this.stats }, removeFile: function(a) { const b = this; a = a.id ? a : b.queue.getFile(a), a.setStatus(i.CANCELLED), b.owner.trigger('fileDequeued', a) }, getFiles: function() { return this.queue.getFiles.apply(this.queue, arguments) }, fetchFile: function() { return this.queue.fetch.apply(this.queue, arguments) }, retry: function(a, b) { let c; let d; let e; const f = this; if (a) return a = a.id ? a : f.queue.getFile(a), a.setStatus(i.QUEUED), void (b || f.request('start-upload')); for (c = f.queue.getFiles(i.ERROR), d = 0, e = c.length; e > d; d++)a = c[d], a.setStatus(i.QUEUED); f.request('start-upload') }, sortFiles: function() { return this.queue.sort.apply(this.queue, arguments) }, reset: function() { this.queue = new c(), this.stats = this.queue.stats } })
    }), b('widgets/runtime', ['uploader', 'runtime/runtime', 'widgets/widget'], function(a, b) { return a.support = function() { return b.hasRuntime.apply(b, arguments) }, a.register({ 'predict-runtime-type': 'predictRuntmeType' }, { init: function() { if (!this.predictRuntmeType()) throw Error('Runtime Error') }, predictRuntmeType: function() { let a; let c; let d = this.options.runtimeOrder || b.orders; let e = this.type; if (!e) for (d = d.split(/\s*,\s*/g), a = 0, c = d.length; c > a; a++) if (b.hasRuntime(d[a])) { this.type = e = d[a]; break } return e } }) }), b('lib/transport', ['base', 'runtime/client', 'mediator'], function(a, b, c) { function d(a) { const c = this; a = c.options = e.extend(!0, {}, d.options, a || {}), b.call(this, 'Transport'), this._blob = null, this._formData = a.formData || {}, this._headers = a.headers || {}, this.on('progress', this._timeout), this.on('load error', function() { c.trigger('progress', 1), clearTimeout(c._timer) }) } var e = a.$; return d.options = { server: '', method: 'POST', withCredentials: !1, fileVal: 'file', timeout: 12e4, formData: {}, headers: {}, sendAsBinary: !1 }, e.extend(d.prototype, { appendBlob: function(a, b, c) { const d = this; const e = d.options; d.getRuid() && d.disconnectRuntime(), d.connectRuntime(b.ruid, function() { d.exec('init') }), d._blob = b, e.fileVal = a || e.fileVal, e.filename = c || e.filename }, append: function(a, b) { typeof a === 'object' ? e.extend(this._formData, a) : this._formData[a] = b }, setRequestHeader: function(a, b) { typeof a === 'object' ? e.extend(this._headers, a) : this._headers[a] = b }, send: function(a) { this.exec('send', a), this._timeout() }, abort: function() { return clearTimeout(this._timer), this.exec('abort') }, destroy: function() { this.trigger('destroy'), this.off(), this.exec('destroy'), this.disconnectRuntime() }, getResponse: function() { return this.exec('getResponse') }, getResponseAsJson: function() { return this.exec('getResponseAsJson') }, getStatus: function() { return this.exec('getStatus') }, _timeout: function() { const a = this; const b = a.options.timeout; b && (clearTimeout(a._timer), a._timer = setTimeout(function() { a.abort(), a.trigger('error', 'timeout') }, b)) } }), c.installTo(d.prototype), d }), b('widgets/upload', ['base', 'uploader', 'file', 'lib/transport', 'widgets/widget'], function(a, b, c, d) {
        function e(a, b) { for (var c, d = [], e = a.source, f = e.size, g = b ? Math.ceil(f / b) : 1, h = 0, i = 0; g > i;)c = Math.min(b, f - h), d.push({ file: a, start: h, end: b ? h + c : f, total: f, chunks: g, chunk: i++ }), h += c; return a.blocks = d.concat(), a.remaning = d.length, { file: a, has: function() { return !!d.length }, fetch: function() { return d.shift() } } } const f = a.$; const g = a.isPromise; const h = c.Status; f.extend(b.options, { prepareNextFile: !1, chunked: !1, chunkSize: 5242880, chunkRetry: 2, threads: 3, formData: null }), b.register({ 'start-upload': 'start', 'stop-upload': 'stop', 'skip-file': 'skipFile', 'is-in-progress': 'isInProgress' }, { init: function() { const b = this.owner; this.runing = !1, this.pool = [], this.pending = [], this.remaning = 0, this.__tick = a.bindFn(this._tick, this), b.on('uploadComplete', function(a) { a.blocks && f.each(a.blocks, function(a, b) { b.transport && (b.transport.abort(), b.transport.destroy()), delete b.transport }), delete a.blocks, delete a.remaning }) }, start: function() { const b = this; f.each(b.request('get-files', h.INVALID), function() { b.request('remove-file', this) }), b.runing || (b.runing = !0, f.each(b.pool, function(a, c) { const d = c.file; d.getStatus() === h.INTERRUPT && (d.setStatus(h.PROGRESS), b._trigged = !1, c.transport && c.transport.send()) }), b._trigged = !1, b.owner.trigger('startUpload'), a.nextTick(b.__tick)) }, stop: function(a) { const b = this; b.runing !== !1 && (b.runing = !1, a && f.each(b.pool, function(a, b) { b.transport && b.transport.abort(), b.file.setStatus(h.INTERRUPT) }), b.owner.trigger('stopUpload')) }, isInProgress: function() { return !!this.runing }, getStats: function() { return this.request('get-stats') }, skipFile: function(a, b) { a = this.request('get-file', a), a.setStatus(b || h.COMPLETE), a.skipped = !0, a.blocks && f.each(a.blocks, function(a, b) { const c = b.transport; c && (c.abort(), c.destroy(), delete b.transport) }), this.owner.trigger('uploadSkip', a) }, _tick: function() { let b; let c; const d = this; const e = d.options; return d._promise ? d._promise.always(d.__tick) : void (d.pool.length < e.threads && (c = d._nextBlock()) ? (d._trigged = !1, b = function(b) { d._promise = null, b && b.file && d._startSend(b), a.nextTick(d.__tick) }, d._promise = g(c) ? c.always(b) : b(c)) : d.remaning || d.getStats().numOfQueue || (d.runing = !1, d._trigged || a.nextTick(function() { d.owner.trigger('uploadFinished') }), d._trigged = !0)) }, _nextBlock: function() { let a; let b; const c = this; let d = c._act; const f = c.options; return d && d.has() && d.file.getStatus() === h.PROGRESS ? (f.prepareNextFile && !c.pending.length && c._prepareNextFile(), d.fetch()) : c.runing ? (!c.pending.length && c.getStats().numOfQueue && c._prepareNextFile(), a = c.pending.shift(), b = function(a) { return a ? (d = e(a, f.chunked ? f.chunkSize : 0), c._act = d, d.fetch()) : null }, g(a) ? a[a.pipe ? 'pipe' : 'then'](b) : b(a)) : void 0 }, _prepareNextFile: function() { let a; const b = this; const c = b.request('fetch-file'); const d = b.pending; c && (a = b.request('before-send-file', c, function() { return c.getStatus() === h.QUEUED ? (b.owner.trigger('uploadStart', c), c.setStatus(h.PROGRESS), c) : b._finishFile(c) }), a.done(function() { const b = f.inArray(a, d); ~b && d.splice(b, 1, c) }), a.fail(function(a) { c.setStatus(h.ERROR, a), b.owner.trigger('uploadError', c, a), b.owner.trigger('uploadComplete', c) }), d.push(a)) }, _popBlock: function(a) { const b = f.inArray(a, this.pool); this.pool.splice(b, 1), a.file.remaning--, this.remaning-- }, _startSend: function(b) { let c; const d = this; const e = b.file; d.pool.push(b), d.remaning++, b.blob = b.chunks === 1 ? e.source : e.source.slice(b.start, b.end), c = d.request('before-send', b, function() { e.getStatus() === h.PROGRESS ? d._doSend(b) : (d._popBlock(b), a.nextTick(d.__tick)) }), c.fail(function() { e.remaning === 1 ? d._finishFile(e).always(function() { b.percentage = 1, d._popBlock(b), d.owner.trigger('uploadComplete', e), a.nextTick(d.__tick) }) : (b.percentage = 1, d._popBlock(b), a.nextTick(d.__tick)) }) }, _doSend: function(b) { let c; let e; const g = this; const i = g.owner; const j = g.options; const k = b.file; const l = new d(j); let m = f.extend({}, j.formData); const n = f.extend({}, j.headers); b.transport = l, l.on('destroy', function() { delete b.transport, g._popBlock(b), a.nextTick(g.__tick) }), l.on('progress', function(a) { let c = 0; let d = 0; c = b.percentage = a, b.chunks > 1 && (f.each(k.blocks, function(a, b) { d += (b.percentage || 0) * (b.end - b.start) }), c = d / k.size), i.trigger('uploadProgress', k, c || 0) }), c = function(a) { let c; return e = l.getResponseAsJson() || {}, e._raw = l.getResponse(), c = function(b) { a = b }, i.trigger('uploadAccept', b, e, c) || (a = a || 'server'), a }, l.on('error', function(a, d) { b.retried = b.retried || 0, b.chunks > 1 && ~'http,abort'.indexOf(a) && b.retried < j.chunkRetry ? (b.retried++, l.send()) : (d || a !== 'server' || (a = c(a)), k.setStatus(h.ERROR, a), i.trigger('uploadError', k, a), i.trigger('uploadComplete', k)) }), l.on('load', function() { let a; return (a = c()) ? void l.trigger('error', a, !0) : void (k.remaning === 1 ? g._finishFile(k, e) : l.destroy()) }), m = f.extend(m, { id: k.id, name: k.name, type: k.type, lastModifiedDate: k.lastModifiedDate, size: k.size }), b.chunks > 1 && f.extend(m, { chunks: b.chunks, chunk: b.chunk }), i.trigger('uploadBeforeSend', b, m, n), l.appendBlob(j.fileVal, b.blob, k.name), l.append(m), l.setRequestHeader(n), l.send() }, _finishFile: function(a, b, c) {
            const d = this.owner; return d.request('after-send-file', arguments, function() { a.setStatus(h.COMPLETE), d.trigger('uploadSuccess', a, b, c) }).fail(function(b) { a.getStatus() === h.PROGRESS && a.setStatus(h.ERROR, b), d.trigger('uploadError', a, b) })
                .always(function() { d.trigger('uploadComplete', a) })
        } })
    }), b('widgets/validator', ['base', 'uploader', 'file', 'widgets/widget'], function(a, b, c) { let d; const e = a.$; const f = {}; return d = { addValidator: function(a, b) { f[a] = b }, removeValidator: function(a) { delete f[a] } }, b.register({ init: function() { const a = this; e.each(f, function() { this.call(a.owner) }) } }), d.addValidator('fileNumLimit', function() { const a = this; const b = a.options; let c = 0; const d = b.fileNumLimit >> 0; let e = !0; d && (a.on('beforeFileQueued', function(a) { return c >= d && e && (e = !1, this.trigger('error', 'Q_EXCEED_NUM_LIMIT', d, a), setTimeout(function() { e = !0 }, 1)), c >= d ? !1 : !0 }), a.on('fileQueued', function() { c++ }), a.on('fileDequeued', function() { c-- }), a.on('uploadFinished', function() { c = 0 })) }), d.addValidator('fileSizeLimit', function() { const a = this; const b = a.options; let c = 0; const d = b.fileSizeLimit >> 0; let e = !0; d && (a.on('beforeFileQueued', function(a) { const b = c + a.size > d; return b && e && (e = !1, this.trigger('error', 'Q_EXCEED_SIZE_LIMIT', d, a), setTimeout(function() { e = !0 }, 1)), b ? !1 : !0 }), a.on('fileQueued', function(a) { c += a.size }), a.on('fileDequeued', function(a) { c -= a.size }), a.on('uploadFinished', function() { c = 0 })) }), d.addValidator('fileSingleSizeLimit', function() { const a = this; const b = a.options; const d = b.fileSingleSizeLimit; d && a.on('beforeFileQueued', function(a) { return a.size > d ? (a.setStatus(c.Status.INVALID, 'exceed_size'), this.trigger('error', 'F_EXCEED_SIZE', a), !1) : void 0 }) }), d.addValidator('duplicate', function() { function a(a) { for (var b, c = 0, d = 0, e = a.length; e > d; d++)b = a.charCodeAt(d), c = b + (c << 6) + (c << 16) - c; return c } const b = this; const c = b.options; const d = {}; c.duplicate || (b.on('beforeFileQueued', function(b) { const c = b.__hash || (b.__hash = a(b.name + b.size + b.lastModifiedDate)); return d[c] ? (this.trigger('error', 'F_DUPLICATE', b), !1) : void 0 }), b.on('fileQueued', function(a) { const b = a.__hash; b && (d[b] = !0) }), b.on('fileDequeued', function(a) { const b = a.__hash; b && delete d[b] })) }), d }), b('runtime/compbase', [], function() { function a(a, b) { this.owner = a, this.options = a.options, this.getRuntime = function() { return b }, this.getRuid = function() { return b.uid }, this.trigger = function() { return a.trigger.apply(a, arguments) } } return a }), b('runtime/html5/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function(b, c, d) { function e() { const a = {}; const d = this; const e = this.destory; c.apply(d, arguments), d.type = f, d.exec = function(c, e) { let f; const h = this; const i = h.uid; const j = b.slice(arguments, 2); return g[c] && (f = a[i] = a[i] || new g[c](h, d), f[e]) ? f[e].apply(f, j) : void 0 }, d.destory = function() { return e && e.apply(this, arguments) } } var f = 'html5'; var g = {}; return b.inherits(c, { constructor: e, init: function() { const a = this; setTimeout(function() { a.trigger('ready') }, 1) } }), e.register = function(a, c) { const e = g[a] = b.inherits(d, c); return e }, a.Blob && a.FileReader && a.DataView && c.addRuntime(f, e), e }), b('runtime/html5/blob', ['runtime/html5/runtime', 'lib/blob'], function(a, b) { return a.register('Blob', { slice: function(a, c) { let d = this.owner.source; const e = d.slice || d.webkitSlice || d.mozSlice; return d = e.call(d, a, c), new b(this.getRuid(), d) } }) }), b('runtime/html5/dnd', ['base', 'runtime/html5/runtime', 'lib/file'], function(a, b, c) { const d = a.$; const e = 'webuploader-dnd-'; return b.register('DragAndDrop', { init: function() { const b = this.elem = this.options.container; this.dragEnterHandler = a.bindFn(this._dragEnterHandler, this), this.dragOverHandler = a.bindFn(this._dragOverHandler, this), this.dragLeaveHandler = a.bindFn(this._dragLeaveHandler, this), this.dropHandler = a.bindFn(this._dropHandler, this), this.dndOver = !1, b.on('dragenter', this.dragEnterHandler), b.on('dragover', this.dragOverHandler), b.on('dragleave', this.dragLeaveHandler), b.on('drop', this.dropHandler), this.options.disableGlobalDnd && (d(document).on('dragover', this.dragOverHandler), d(document).on('drop', this.dropHandler)) }, _dragEnterHandler: function(a) { let b; const c = this; let d = c._denied || !1; return a = a.originalEvent || a, c.dndOver || (c.dndOver = !0, b = a.dataTransfer.items, b && b.length && (c._denied = d = !c.trigger('accept', b)), c.elem.addClass(e + 'over'), c.elem[d ? 'addClass' : 'removeClass'](e + 'denied')), a.dataTransfer.dropEffect = d ? 'none' : 'copy', !1 }, _dragOverHandler: function(a) { const b = this.elem.parent().get(0); return b && !d.contains(b, a.currentTarget) ? !1 : (clearTimeout(this._leaveTimer), this._dragEnterHandler.call(this, a), !1) }, _dragLeaveHandler: function() { let a; const b = this; return a = function() { b.dndOver = !1, b.elem.removeClass(e + 'over ' + e + 'denied') }, clearTimeout(b._leaveTimer), b._leaveTimer = setTimeout(a, 100), !1 }, _dropHandler: function(a) { const b = this; const f = b.getRuid(); const g = b.elem.parent().get(0); return g && !d.contains(g, a.currentTarget) ? !1 : (b._getTansferFiles(a, function(a) { b.trigger('drop', d.map(a, function(a) { return new c(f, a) })) }), b.dndOver = !1, b.elem.removeClass(e + 'over'), !1) }, _getTansferFiles: function(b, c) { let d; let e; let f; let g; let h; let i; let j; let k; const l = []; const m = []; for (b = b.originalEvent || b, f = b.dataTransfer, d = f.items, e = f.files, k = !(!d || !d[0].webkitGetAsEntry), i = 0, j = e.length; j > i; i++)g = e[i], h = d && d[i], k && h.webkitGetAsEntry().isDirectory ? m.push(this._traverseDirectoryTree(h.webkitGetAsEntry(), l)) : l.push(g); a.when.apply(a, m).done(function() { l.length && c(l) }) }, _traverseDirectoryTree: function(b, c) { const d = a.Deferred(); const e = this; return b.isFile ? b.file(function(a) { c.push(a), d.resolve() }) : b.isDirectory && b.createReader().readEntries(function(b) { let f; const g = b.length; const h = []; const i = []; for (f = 0; g > f; f++)h.push(e._traverseDirectoryTree(b[f], i)); a.when.apply(a, h).then(function() { c.push.apply(c, i), d.resolve() }, d.reject) }), d.promise() }, destroy: function() { const a = this.elem; a.off('dragenter', this.dragEnterHandler), a.off('dragover', this.dragEnterHandler), a.off('dragleave', this.dragLeaveHandler), a.off('drop', this.dropHandler), this.options.disableGlobalDnd && (d(document).off('dragover', this.dragOverHandler), d(document).off('drop', this.dropHandler)) } }) }), b('runtime/html5/filepaste', ['base', 'runtime/html5/runtime', 'lib/file'], function(a, b, c) {
        return b.register('FilePaste', { init: function() {
            let b; let c; let d; let e; const f = this.options; const g = this.elem = f.container; let h = '.*'; if (f.accept) {
                for (b = [], c = 0, d = f.accept.length; d > c; c++)e = f.accept[c].mimeTypes, e && b.push(e); b.length && (h = b.join(','), h = h.replace(/,/g, '|').replace(/\*/g, '.*'))
            } this.accept = h = new RegExp(h, 'i'), this.hander = a.bindFn(this._pasteHander, this), g.on('paste', this.hander)
        }, _pasteHander: function(a) { let b; let d; let e; let f; let g; const h = []; const i = this.getRuid(); for (a = a.originalEvent || a, b = a.clipboardData.items, f = 0, g = b.length; g > f; f++)d = b[f], d.kind === 'file' && (e = d.getAsFile()) && h.push(new c(i, e)); h.length && (a.preventDefault(), a.stopPropagation(), this.trigger('paste', h)) }, destroy: function() { this.elem.off('paste', this.hander) } })
    }), b('runtime/html5/filepicker', ['base', 'runtime/html5/runtime'], function(a, b) {
        const c = a.$; return b.register('FilePicker', { init: function() {
            let a; let b; let d; let e; const f = this.getRuntime().getContainer(); const g = this; const h = g.owner; const i = g.options; const j = c(document.createElement('label')); let k = c(document.createElement('input')); if (k.attr('type', 'file'), k.attr('name', i.name), k.addClass('webuploader-element-invisible'), j.on('click', function() { k.trigger('click') }), j.css({ opacity: 0, width: '100%', height: '100%', display: 'block', cursor: 'pointer', background: '#ffffff' }), i.multiple && k.attr('multiple', 'multiple'), i.accept && i.accept.length > 0) { for (a = [], b = 0, d = i.accept.length; d > b; b++)a.push(i.accept[b].mimeTypes); k.attr('accept', a.join(',')) }f.append(k), f.append(j), e = function(a) { h.trigger(a.type) }, k.on('change', function(a) {
                let b; const d = arguments.callee; g.files = a.target.files, b = this.cloneNode(!0), this.parentNode.replaceChild(b, this), k.off(), k = c(b).on('change', d)
                    .on('mouseenter mouseleave', e), h.trigger('change')
            }), j.on('mouseenter mouseleave', e)
        }, getFiles: function() { return this.files }, destroy: function() {} })
    }), b('runtime/html5/transport', ['base', 'runtime/html5/runtime'], function(a, b) { const c = a.noop; const d = a.$; return b.register('Transport', { init: function() { this._status = 0, this._response = null }, send: function() { let b; let c; let e; const f = this.owner; const g = this.options; const h = this._initAjax(); const i = f._blob; let j = g.server; g.sendAsBinary ? (j += (/\?/.test(j) ? '&' : '?') + d.param(f._formData), c = i.getSource()) : (b = new FormData(), d.each(f._formData, function(a, c) { b.append(a, c) }), b.append(g.fileVal, i.getSource(), g.filename || f._formData.name || '')), g.withCredentials && 'withCredentials' in h ? (h.open(g.method, j, !0), h.withCredentials = !0) : h.open(g.method, j), this._setRequestHeader(h, g.headers), c ? (h.overrideMimeType('application/octet-stream'), a.os.android ? (e = new FileReader(), e.onload = function() { h.send(this.result), e = e.onload = null }, e.readAsArrayBuffer(c)) : h.send(c)) : h.send(b) }, getResponse: function() { return this._response }, getResponseAsJson: function() { return this._parseJson(this._response) }, getStatus: function() { return this._status }, abort: function() { let a = this._xhr; a && (a.upload.onprogress = c, a.onreadystatechange = c, a.abort(), this._xhr = a = null) }, destroy: function() { this.abort() }, _initAjax: function() { const a = this; let b = new XMLHttpRequest(); const d = this.options; return !d.withCredentials || 'withCredentials' in b || typeof XDomainRequest === 'undefined' || (b = new XDomainRequest()), b.upload.onprogress = function(b) { let c = 0; return b.lengthComputable && (c = b.loaded / b.total), a.trigger('progress', c) }, b.onreadystatechange = function() { return b.readyState === 4 ? (b.upload.onprogress = c, b.onreadystatechange = c, a._xhr = null, a._status = b.status, b.status >= 200 && b.status < 300 ? (a._response = b.responseText, a.trigger('load')) : b.status >= 500 && b.status < 600 ? (a._response = b.responseText, a.trigger('error', 'server')) : a.trigger('error', a._status ? 'http' : 'abort')) : void 0 }, a._xhr = b, b }, _setRequestHeader: function(a, b) { d.each(b, function(b, c) { a.setRequestHeader(b, c) }) }, _parseJson: function(a) { let b; try { b = JSON.parse(a) } catch (c) { b = {} } return b } }) }), b('runtime/flash/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function(b, c, d) { function e() { let a; try { a = navigator.plugins['Shockwave Flash'], a = a.description } catch (b) { try { a = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version') } catch (c) { a = '0.0' } } return a = a.match(/\d+/g), parseFloat(a[0] + '.' + a[1], 10) } function f() { function d(a, b) { let c; let d; let e = a.type || a; c = e.split('::'), d = c[0], e = c[1], e === 'Ready' && d === j.uid ? j.trigger('ready') : f[d] && f[d].trigger(e.toLowerCase(), a, b) } const e = {}; var f = {}; const g = this.destory; var j = this; const k = b.guid('webuploader_'); c.apply(j, arguments), j.type = h, j.exec = function(a, c) { let d; const g = this; const h = g.uid; const k = b.slice(arguments, 2); return f[h] = g, i[a] && (e[h] || (e[h] = new i[a](g, j)), d = e[h], d[c]) ? d[c].apply(d, k) : j.flashExec.apply(g, arguments) }, a[k] = function() { const a = arguments; setTimeout(function() { d.apply(null, a) }, 1) }, this.jsreciver = k, this.destory = function() { return g && g.apply(this, arguments) }, this.flashExec = function(a, c) { const d = j.getFlash(); const e = b.slice(arguments, 2); return d.exec(this.uid, a, c, e) } } const g = b.$; var h = 'flash'; var i = {}; return b.inherits(c, { constructor: f, init: function() { let a; const c = this.getContainer(); const d = this.options; c.css({ position: 'absolute', top: '-8px', left: '-8px', width: '9px', height: '9px', overflow: 'hidden' }), a = '<object id="' + this.uid + '" type="application/x-shockwave-flash" data="' + d.swf + '" ', b.browser.ie && (a += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '), a += 'width="100%" height="100%" style="outline:0"><param name="movie" value="' + d.swf + '" /><param name="flashvars" value="uid=' + this.uid + '&jsreciver=' + this.jsreciver + '" /><param name="wmode" value="transparent" /><param name="allowscriptaccess" value="always" /></object>', c.html(a) }, getFlash: function() { return this._flash ? this._flash : (this._flash = g('#' + this.uid).get(0), this._flash) } }), f.register = function(a, c) { return c = i[a] = b.inherits(d, g.extend({ flashExec: function() { const a = this.owner; const b = this.getRuntime(); return b.flashExec.apply(a, arguments) } }, c)) }, e() >= 11.4 && c.addRuntime(h, f), f }), b('runtime/flash/filepicker', ['base', 'runtime/flash/runtime'], function(a, b) { const c = a.$; return b.register('FilePicker', { init: function(a) { let b; let d; const e = c.extend({}, a); for (b = e.accept && e.accept.length, d = 0; b > d; d++)e.accept[d].title || (e.accept[d].title = 'Files'); delete e.button, delete e.container, this.flashExec('FilePicker', 'init', e) }, destroy: function() {} }) }), b('runtime/flash/transport', ['base', 'runtime/flash/runtime', 'runtime/client'], function(a, b, c) { const d = a.$; return b.register('Transport', { init: function() { this._status = 0, this._response = null, this._responseJson = null }, send: function() { let a; const b = this.owner; const c = this.options; const e = this._initAjax(); const f = b._blob; let g = c.server; e.connectRuntime(f.ruid), c.sendAsBinary ? (g += (/\?/.test(g) ? '&' : '?') + d.param(b._formData), a = f.uid) : (d.each(b._formData, function(a, b) { e.exec('append', a, b) }), e.exec('appendBlob', c.fileVal, f.uid, c.filename || b._formData.name || '')), this._setRequestHeader(e, c.headers), e.exec('send', { method: c.method, url: g }, a) }, getStatus: function() { return this._status }, getResponse: function() { return this._response }, getResponseAsJson: function() { return this._responseJson }, abort: function() { let a = this._xhr; a && (a.exec('abort'), a.destroy(), this._xhr = a = null) }, destroy: function() { this.abort() }, _initAjax: function() { const a = this; let b = new c('XMLHttpRequest'); return b.on('uploadprogress progress', function(b) { return a.trigger('progress', b.loaded / b.total) }), b.on('load', function() { const c = b.exec('getStatus'); let d = ''; return b.off(), a._xhr = null, c >= 200 && c < 300 ? (a._response = b.exec('getResponse'), a._responseJson = b.exec('getResponseAsJson')) : c >= 500 && c < 600 ? (a._response = b.exec('getResponse'), a._responseJson = b.exec('getResponseAsJson'), d = 'server') : d = 'http', b.destroy(), b = null, d ? a.trigger('error', d) : a.trigger('load') }), b.on('error', function() { b.off(), a._xhr = null, a.trigger('error', 'http') }), a._xhr = b, b }, _setRequestHeader: function(a, b) { d.each(b, function(b, c) { a.exec('setRequestHeader', b, c) }) } }) }), b('preset/withoutimage', ['base', 'widgets/filednd', 'widgets/filepaste', 'widgets/filepicker', 'widgets/queue', 'widgets/runtime', 'widgets/upload', 'widgets/validator', 'runtime/html5/blob', 'runtime/html5/dnd', 'runtime/html5/filepaste', 'runtime/html5/filepicker', 'runtime/html5/transport', 'runtime/flash/filepicker', 'runtime/flash/transport'], function(a) { return a }), b('webuploader', ['preset/withoutimage'], function(a) { return a }), c('webuploader')
}))
